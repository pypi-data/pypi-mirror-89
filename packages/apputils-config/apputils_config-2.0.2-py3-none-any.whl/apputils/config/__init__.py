#  Licensed to the Apache Software Foundation (ASF) under one or more
#  contributor license agreements.  See the NOTICE file distributed with
#  this work for additional information regarding copyright ownership.
#  The ASF licenses this file to You under the Apache License, Version 2.0
#  (the "License"); you may not use this file except in compliance with
#  the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
#  Github: https://github.com/hapylestat/apputils
#
#


from .base_storage import BaseStorage
from .sql_storage import SQLStorage, StorageProperty, StoragePropertyType
from typing import ClassVar

import sys
import time
from getpass import getpass


class Configuration(object):
  __cache_invalidation: float = time.mktime(time.gmtime(8 * 3600))  # 8 hours
  __options_table = "general"
  __cache_table = "cache"

  def __init__(self, app_name: str, app_version: str, storage_cls: ClassVar[BaseStorage] = SQLStorage):
    self.__storage = storage_cls(app_name=app_name, app_version=app_version)

  def initialize(self):
    if self.__is_conf_initialized:
      self.__storage.initialize_key()
      try:
        assert self.__test_encrypted_property == "test"
      except ValueError as e:
        print(f"Error: {str(e)}")
        sys.exit(-1)
    else:
      self.__initial_configuration()

  def __ask_text_question(self, prompt: str, encrypted: bool = False) -> str:
    f = getpass if encrypted else input
    answer = f(prompt)
    return answer

  def __ask_question(self, prompt: str, encrypted: bool = False) -> bool:
    answer = self.__ask_text_question(prompt, encrypted).lower()
    return answer == "y" or answer == "yes"

  @property
  def configuration_dir(self):
    return self.__storage.configuration_dir

  def set_property(self, name: str, value: str, is_encrypted: bool = False):
    self.__storage.set_text_property(self.__options_table, name, value, encrypted=is_encrypted)

  def get_property(self, name: str) -> str:
    return self.__storage.get_property(self.__options_table, name, StorageProperty()).value

  def is_exists(self, name: str) -> bool:
    return self.__storage.property_existed(self.__options_table, name)

  @property
  def __is_conf_initialized(self):
    return self.__storage.get_property(self.__options_table, "initialized", StorageProperty()).value == "1"

  @__is_conf_initialized.setter
  def __is_conf_initialized(self, value):
    self.__storage.set_text_property(self.__options_table, "initialized", "1")

  @property
  def __test_encrypted_property(self):
    return self.__storage.get_property(self.__options_table, "enctest", StorageProperty()).value

  def invalidate_cache(self):
    self.__storage.reset_properties_update_time(self.__cache_table)

  @__test_encrypted_property.setter
  def __test_encrypted_property(self, value):
    self.__storage.set_text_property(self.__options_table, "enctest", value, encrypted=True)

  def __initial_configuration(self):
    print("""
    Encryption key
    --------------
    It is used to secure user-sensitive data like username or passwords. The key is generated by using
    master password as salt and could be cached on disk to avoid re-typing it each time, else master password
    need to be entered each time.

    """)

    use_master_password: bool = self.__ask_question("Secure credentials with master password (y/n): ")
    if use_master_password:
      store_encryption_key: bool = self.__ask_question("Cache encryption key on disk (y/n): ")
    else:  # if not master key is used, default one would be generated anyway
      store_encryption_key: bool = True

    self.__storage.create_key(store_encryption_key, None if use_master_password else "")
    self.__storage.initialize_key()

    self.__test_encrypted_property = "test"
    self.__is_conf_initialized = True

    print("Tool configuration is done, thanks!")

  def reset(self):
    self.__storage.reset()
