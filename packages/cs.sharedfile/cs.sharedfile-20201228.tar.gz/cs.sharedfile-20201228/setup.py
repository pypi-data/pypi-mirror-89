#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.sharedfile',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20201228',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  description =
    'facilities for shared access to files',
  long_description =
    ('Facilities for shared access to files.\n'    
 '\n'    
 '*Latest release 20201228*:\n'    
 'New SharedWriteable class to manage concurrent output with a mutexed .write '    
 'method and a context manager for grouping larger uses.\n'    
 '\n'    
 '## Function `lockfile(path, ext=None, poll_interval=None, timeout=None)`\n'    
 '\n'    
 'A context manager which takes and holds a lock file.\n'    
 '\n'    
 'Parameters:\n'    
 '* `path`: the base associated with the lock file.\n'    
 '* `ext`:\n'    
 '  the extension to the base used to construct the lock file name.\n'    
 '  Default: `".lock"`\n'    
 '* `timeout`: maximum time to wait before failing,\n'    
 '  default None (wait forever).\n'    
 '* `poll_interval`: polling frequency when timeout is not 0.\n'    
 '\n'    
 '## Class `SharedAppendFile`\n'    
 '\n'    
 'A base class to share a modifiable file between multiple users.\n'    
 '\n'    
 'The use case was driven from the shared CSV files used by\n'    
 '`cs.nodedb.csvdb.Backend_CSVFile`, where multiple users can\n'    
 'read from a common CSV file, and coordinate updates with a\n'    
 'lock file.\n'    
 '\n'    
 'This presents the following interfaces:\n'    
 '* `__iter__`: yields data chunks from the underlying file up\n'    
 '  to EOF; it blocks no more than reading from the file does.\n'    
 '  Note that multiple iterators share the same read pointer.\n'    
 '\n'    
 '* `open`: a context manager returning a writable file for writing\n'    
 '  updates to the file; it blocks reads from this instance\n'    
 '  (though not, of course, by other users of the file) and\n'    
 '  arranges that users of `__iter__` do not receive their own\n'    
 '  written data, thus arranging that `__iter__` returns only\n'    
 '  foreign file updates.\n'    
 '\n'    
 'Subclasses would normally override `__iter__` to parse the\n'    
 'received data into their natural records.\n'    
 '\n'    
 '### Method `SharedAppendFile.__init__(self, pathname, read_only=False, '    
 'write_only=False, binary=False, newline=None, lock_ext=None, '    
 'lock_timeout=None, poll_interval=None)`\n'    
 '\n'    
 'Initialise this SharedAppendFile.\n'    
 '\n'    
 'Parameters:\n'    
 '* `pathname`: the pathname of the file to open.\n'    
 '* `read_only`: set to true if we will not write updates.\n'    
 '* `write_only`: set to true if we will not read updates.\n'    
 '* `binary`: if the file is to be opened in binary mode, otherwise text '    
 'mode.\n'    
 "* 'newline`: passed to `open()`\n"    
 '* `lock_ext`: lock file extension.\n'    
 '* `lock_timeout`: maxmimum time to wait for obtaining the lock file.\n'    
 '* `poll_interval`: poll time when taking a lock file,\n'    
 '  default `DEFAULT_POLL_INTERVAL`\n'    
 '\n'    
 '### Method `SharedAppendFile.__iter__(self)`\n'    
 '\n'    
 'Iterate over the file, yielding data chunks until EOF.\n'    
 '\n'    
 'This skips data written to the file by this instance so that\n'    
 'the data chunks returned are always foreign updates.\n'    
 'Note that all iterators share the same file offset pointer.\n'    
 '\n'    
 'Usage:\n'    
 '\n'    
 '    for chunk in f:\n'    
 '        ... process chunk ...\n'    
 '\n'    
 '### Method `SharedAppendFile.close(self)`\n'    
 '\n'    
 'Close the SharedAppendFile: close input queue, wait for monitor to '    
 'terminate.\n'    
 '\n'    
 '### Property `SharedAppendFile.filestate`\n'    
 '\n'    
 'The current FileState of the backing file.\n'    
 '\n'    
 '### Method `SharedAppendFile.open(self)`\n'    
 '\n'    
 'Open the file for append write, returing a writable file.\n'    
 'Iterators are blocked for the duration of the context manager.\n'    
 '\n'    
 '### Method `SharedAppendFile.rewrite(self)`\n'    
 '\n'    
 'Context manager for rewriting the file.\n'    
 '\n'    
 'This writes data to a new file which is then renamed onto the original.\n'    
 'After the switch, the read pointer is set to the end of the new file.\n'    
 '\n'    
 'Usage:\n'    
 '\n'    
 '    with f.rewrite() as wfp:\n'    
 '        ... write data to wfp ...\n'    
 '\n'    
 '### Method `SharedAppendFile.tail(self)`\n'    
 '\n'    
 'A generator returning data chunks from the file indefinitely.\n'    
 '\n'    
 'This supports writing monitors for file updates.\n'    
 'Note that this, like other iterators, shares the same file offset pointer.\n'    
 "Also note that it calls the class' iterator, so that if a\n"    
 'subsclass returns higher level records from its iterator,\n'    
 'those records will also be returned from tail.\n'    
 '\n'    
 'Usage:\n'    
 '\n'    
 '    for chunk in f:\n'    
 '        ... process chunk ...\n'    
 '\n'    
 '## Class `SharedAppendLines(SharedAppendFile)`\n'    
 '\n'    
 'A line oriented subclass of `SharedAppendFile`.\n'    
 '\n'    
 '## Class `SharedCSVFile(SharedAppendLines,SharedAppendFile)`\n'    
 '\n'    
 'Shared access to a CSV file in UTF-8 encoding.\n'    
 '\n'    
 '### Method `SharedCSVFile.__iter__(self)`\n'    
 '\n'    
 'Yield csv rows.\n'    
 '\n'    
 '### Method `SharedCSVFile.writer(self)`\n'    
 '\n'    
 'Context manager for appending to a CSV file.\n'    
 '\n'    
 '## Class `SharedWriteable`\n'    
 '\n'    
 'Wrapper for a writable file with supported mutex based cooperation.\n'    
 '\n'    
 'This is mostly a proxy for the wrapped file\n'    
 'exceptthat all `.write` calls are serialised\n'    
 'and when used as a context manager\n'    
 'other writers are blocked.\n'    
 '\n'    
 'This is to support shared use of an output stream\n'    
 'where certain outputs should be contiguous,\n'    
 'such as a standard error stream used to maintain a status line\n'    
 'or multiline messages.\n'    
 '\n'    
 '### Method `SharedWriteable.__enter__(self)`\n'    
 '\n'    
 'Take the lock and return.\n'    
 '\n'    
 '### Method `SharedWriteable.__exit__(self, *_)`\n'    
 '\n'    
 'Release the lock and proceed.\n'    
 '\n'    
 '### Method `SharedWriteable.__getattr__(self, attr)`\n'    
 '\n'    
 'This object is mostly a proxy for the wrapped file.\n'    
 '\n'    
 '### Method `SharedWriteable.write(self, s)`\n'    
 '\n'    
 'Obtain the lock and then run the wrapped `.write` method.\n'    
 '\n'    
 '# Release Log\n'    
 '\n'    
 '\n'    
 '\n'    
 '*Release 20201228*:\n'    
 'New SharedWriteable class to manage concurrent output with a mutexed .write '    
 'method and a context manager for grouping larger uses.\n'    
 '\n'    
 '*Release 20190102*:\n'    
 'Context manager bugfix.\n'    
 '\n'    
 '*Release 20170608*:\n'    
 '* Facilities for shared files, split out from cs.fileutils.\n'    
 '* SharedAppend* classes. lockfile function.'),
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  install_requires = ['cs.filestate', 'cs.lex', 'cs.logutils', 'cs.pfx', 'cs.range', 'cs.timeutils'],
  keywords = ['python2', 'python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.sharedfile'],
)
