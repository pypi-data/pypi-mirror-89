"""Print a formatted report."""
from typing import Union, Callable, IO, Set
import sys

from flake8_report.flake8_error import Flake8Error
from flake8_report.formatters import OutputGenerator
from flake8_report.formatters.codes_lookup import lookup_code_title
from flake8_report.formatters.group_by import Grouping, Group


class ReportGenerator(OutputGenerator):
    """Generate the formatted report."""

    def __init__(self, features: Set[int] = None, write_to: Union[Callable, IO] = sys.stdout):
        if not features:
            features = {self.SHOW_ROW_COL, self.SHOW_MODULE}
        super().__init__(features=features, write_to=write_to)

    def generate(self, error_groups: Grouping, verbose: bool = False):
        """Generate ungrouped report listing.

        This expects the `error_groups` to have only a single group it in. If
        we happen to have > 1, this will instead invoke :py:class:`GroupReportGenerator`.

        :param error_groups:
        :param verbose:
        :return:
        """
        generator = self
        # TODO: Silly logic. Should be part of the factory method

        if len(error_groups) > 1:
            generator = GroupReportGenerator(features=self.features,
                                             write_to=self.write_to)

        elif not len(error_groups):
            print('No errors to generate report from')

        generator.render_report(error_groups=error_groups)

    def render_report(self, error_groups: Grouping, verbose: bool = False) -> None:
        """Render the report.

        :param error_groups: The Grouping
        :param verbose: True to output more details
        :return:
        """
        if verbose:
            print('Rendering report: ReportGenerator')

        self.render_header(error_groups=error_groups, verbose=verbose)
        self.render_body(error_groups=error_groups)

    def render_header(self, error_groups: Grouping, verbose: bool = False) -> None:
        """Generate the report header section.

        There are several optional fields:

        * CI_PIPELINE_ID: Only this environment var is present
        * is_pipeline: Only if the report was generated within a Gitlab pipeline

        """
        import locale
        import os

        locale.setlocale(locale.LC_ALL, '')

        ci_pipeline = os.environ.get('CI_PIPELINE_ID')
        all_codes = error_groups.codes()
        err_count = error_groups.error_count()

        self.render_line('Flake8 Error Report - generated by flake8-report plugin\n')

        self.render_line('Report date    : {}'.format(self.get_report_time()))
        self.render_line('Total errors   : {:n}'.format(err_count))
        self.render_line('All error codes: {}'.format(','.join(all_codes)))
        self.render_line('Verbose        : {}'.format(['No', 'Yes'][verbose]))

        if ci_pipeline:
            self.render_line('CI_PIPELINE_ID : {}'.format(ci_pipeline))

    def render_body(self, error_groups: Grouping) -> None:
        """Render the report body."""
        group = error_groups.groups[0]

        self.render_blank_line()

        for err in group.errors:
            row = err.row if self.show_row_col else ''
            column = err.column if self.show_row_col else ''

            self.render_line('{mod:55}:{row:}{col:} {code:4} {msg}'.format(
                mod=err.module.fit_path(55),
                row=row,
                col=column,
                code=err.code,
                msg=err.message
            ))

            # Optionally render the code line(s) for the error
            if self.show_text:
                self.render_code_text(err.line_text)

    def render_footer(self) -> None:
        """Render the optional footer"""
        self.render_blank_line()
        self.render_line('Generated report on {}'.format(self.get_report_time()))


class GroupReportGenerator(ReportGenerator):
    """Generate a formatted report grouped by either code or module path."""

    def __init__(self, features: Set[int] = None, write_to: Union[Callable, IO] = sys.stdout):
        super().__init__(features=features, write_to=write_to)

    def generate(self, error_groups: Grouping, verbose: bool = False):
        """Generate a grouped report."""
        self.render_report(error_groups=error_groups, verbose=verbose)

    def render_report(self, error_groups: Grouping, verbose: bool = False):
        """Generate grouped report."""
        if verbose:
            print('Rendering report: ReportGenerator')

        self.render_header(error_groups=error_groups, verbose=verbose)
        self.render_body(error_groups=error_groups)
        self.render_footer()

    def render_body(self, error_groups: Grouping):
        """Render the body."""
        self.render_blank_line()

        # Iterate each group
        for group in error_groups.groups:

            self._render_grp_title(key=group.key, group_label=error_groups.label)
            self.render_line('-' * 80)

            self._render_body_group(group=group, group_label=error_groups.label)

            self.render_blank_line()

    def _render_grp_title(self, key: str, group_label: str):
        """Render the title of the group"""
        if group_label == 'path':
            self.render_line(key)

        elif group_label == 'code':
            title = lookup_code_title(code=key, default="Code description text not found")

            self.render_line('{} - {}'.format(key, title))

    def _render_body_group(self, group: Group, group_label: str) -> None:
        """Render the list of errors"""
        # Iterate each error within the group
        for error in group.errors:
            # TODO: This approach will make it more difficult to add a new grouping
            if group_label == 'path':
                self._render_body_by_path(error=error)

            elif group_label == 'code':
                self._render_body_by_code(error=error)

            # Optionally render the code line(s) for the error
            if self.show_text:
                self.render_code_text(error.line_text)
                self.render_blank_line()

    def _render_body_by_code(self, error: Flake8Error):
        rc = '({}:{})'.format(error.row, error.column)

        self.render_line('{path:4}:{row:>7}  {msg}'.format(
            path=error.module.fit_path(max_len=70),
            row=rc,
            msg=error.message
        ))

    def _render_body_by_path(self, error: Flake8Error):
        rc = '({}:{})'.format(error.row, error.column)

        self.render_line('{code:4} {row:>7}  {msg}'.format(
            code=error.code,
            row=rc,
            msg=error.message
        ))
