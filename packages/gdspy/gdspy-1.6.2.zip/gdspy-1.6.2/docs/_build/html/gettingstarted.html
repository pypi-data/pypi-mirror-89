

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started &mdash; gdspy 1.6 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="reference.html" />
    <link rel="prev" title="Gdspy’s Documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> gdspy
          

          
          </a>

          
            
            
              <div class="version">
                1.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#first-gdsii">First GDSII</a></li>
<li class="toctree-l2"><a class="reference internal" href="#polygons">Polygons</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#holes">Holes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#circles">Circles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#curves">Curves</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transformations">Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#layer-and-datatype">Layer and Datatype</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paths">Paths</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#polygonal-only-paths">Polygonal-Only Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flexible-paths">Flexible Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#robust-paths">Robust Paths</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#text">Text</a></li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-operations">Geometry Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#boolean-operations">Boolean Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slice-operation">Slice Operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#offset-operation">Offset Operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fillet-operation">Fillet Operation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gdsii-library">GDSII Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#units-in-gdsii">Units in GDSII</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saving-a-gdsii-file">Saving a GDSII File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-a-gdsii-file">Loading a GDSII File</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integrated-photonics">Integrated Photonics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-system-fonts">Using System Fonts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">gdspy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Getting Started</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/gettingstarted.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>GDSII files contain a hierarchical representation of any polygonal geometry.
They are mainly used in the microelectronics industry for the design of mask layouts, but are also employed in other areas.</p>
<p>Because it is a hierarchical format, repeated structures, such as identical transistors, can be defined once and referenced multiple times in the layout, reducing the file size.</p>
<p>There is one important limitation in the GDSII format: it only supports <a class="reference external" href="https://en.wikipedia.org/wiki/Simple_polygon">weakly simple polygons</a>, that is, polygons whose segments are allowed to intersect, but not cross.</p>
<p>In particular, curves and shapes with holes are <em>not</em> directly supported.
Holes can be defined, nonetheless, by connecting their boundary to the boundary of the enclosing shape.
In the case of curves, they must be approximated by a polygon.
The number of points in the polygonal approximation can be increased to better approximate the original curve up to some acceptable error.</p>
<p>The original GDSII format limits the number of vertices in a polygon to 199.
This limit seems arbitrary, as the maximal number of vertices that can be stored in a GDSII record is 8190.
Nonetheless, most modern software disregard both limits and allow an arbitrary number of points per polygon.
Gdspy follows the modern version of GDSII, but this is an important issue to keep in mind if the generated file is to be used in older systems.</p>
<p>The units used to represent shapes in the GDSII format are defined by the user.
The default unit in gdspy is 1 µm (10⁻⁶ m), but that can be easily changed by the user.</p>
<div class="section" id="first-gdsii">
<h2>First GDSII<a class="headerlink" href="#first-gdsii" title="Permalink to this headline">¶</a></h2>
<p>Let’s create our first GDSII file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gdspy</span>

<span class="c1"># The GDSII file is called a library, which contains multiple cells.</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">GdsLibrary</span><span class="p">()</span>

<span class="c1"># Geometry must be placed in cells.</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s1">&#39;FIRST&#39;</span><span class="p">)</span>

<span class="c1"># Create the geometry (a single rectangle) and add it to the cell.</span>
<span class="n">rect</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>

<span class="c1"># Save the library in a file called &#39;first.gds&#39;.</span>
<span class="n">lib</span><span class="o">.</span><span class="n">write_gds</span><span class="p">(</span><span class="s1">&#39;first.gds&#39;</span><span class="p">)</span>

<span class="c1"># Optionally, save an image of the cell as SVG.</span>
<span class="n">cell</span><span class="o">.</span><span class="n">write_svg</span><span class="p">(</span><span class="s1">&#39;first.svg&#39;</span><span class="p">)</span>

<span class="c1"># Display all cells using the internal viewer.</span>
<span class="n">gdspy</span><span class="o">.</span><span class="n">LayoutViewer</span><span class="p">()</span>
</pre></div>
</div>
<p>After importing the <cite>gdspy</cite> module, we create a library <cite>lib</cite> to hold the design.
Then a <a class="reference internal" href="reference.html#gdspy.Cell" title="gdspy.Cell"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Cell</span></code></a> is created and the rectangle is added to the cell.
All shapes in the GDSII format exist inside cells.
A cell can be imagined as a piece of paper where the layout will be defined.
Later, the cells can be used to create a hierarchy of geometries, ass we’ll see in <a class="reference internal" href="#references"><span class="std std-ref">References</span></a>.</p>
<p>Finally, the whole structure is saved in a file called “first.gds” in the current directory.
By default, all created cells are included in this operation.</p>
<p>The GDSII file can be opened in a number of viewers and editors, such as <a class="reference external" href="https://klayout.de/">KLayout</a>.
Alternatively, gdspy includes a simple viewer that can also be used: <a class="reference internal" href="reference.html#gdspy.LayoutViewer" title="gdspy.LayoutViewer"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.LayoutViewer</span></code></a>.</p>
</div>
<div class="section" id="polygons">
<h2>Polygons<a class="headerlink" href="#polygons" title="Permalink to this headline">¶</a></h2>
<p>General polygons can be defined by an ordered list of vertices.
The orientation of the vertices (clockwise/counter-clockwise) is not important.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a polygon from a list of vertices</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="n">poly</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/polygons.svg" class="align-center" src="_images/polygons.svg" /><div class="section" id="holes">
<h3>Holes<a class="headerlink" href="#holes" title="Permalink to this headline">¶</a></h3>
<p>As mentioned in <a class="reference internal" href="#getting-started"><span class="std std-ref">Getting Started</span></a>, holes have to be connected to the outer boundary of the polygon, as in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Manually connect the hole to the outer boundary</span>
<span class="n">cutout</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="p">)</span>
</pre></div>
</div>
<img alt="_images/holes.svg" class="align-center" src="_images/holes.svg" /></div>
<div class="section" id="circles">
<h3>Circles<a class="headerlink" href="#circles" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="reference.html#gdspy.Round" title="gdspy.Round"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Round</span></code></a> class creates circles, ellipses, doughnuts, arcs and slices.
In all cases, the arguments <cite>tolerance</cite> or <cite>number_of_points</cite> will control the number of vertices used to approximate the curved shapes.</p>
<p>If the number of vertices in the polygon is larger than <cite>max_points</cite> (199 by default), it will be fractured in many smaller polygons with at most <cite>max_points</cite> vertices each.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Circle centered at (0, 0), with radius 2 and tolerance 0.1</span>
<span class="n">circle</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># To create an ellipse, simply pass a list with 2 radii.</span>
<span class="c1"># Because the tolerance is small (resulting a large number of</span>
<span class="c1"># vertices), the ellipse is fractured in 2 polygons.</span>
<span class="n">ellipse</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

<span class="c1"># Circular arc example</span>
<span class="n">arc</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">(</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">inner_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">initial_angle</span><span class="o">=-</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
    <span class="n">final_angle</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<img alt="_images/circles.svg" class="align-center" src="_images/circles.svg" /></div>
<div class="section" id="curves">
<h3>Curves<a class="headerlink" href="#curves" title="Permalink to this headline">¶</a></h3>
<p>Constructing complex polygons by manually listing all vertices in <a class="reference internal" href="reference.html#gdspy.Polygon" title="gdspy.Polygon"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Polygon</span></code></a> can be challenging.
The class <a class="reference internal" href="reference.html#gdspy.Curve" title="gdspy.Curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Curve</span></code></a> can be used to facilitate the creation of polygons by drawing their shapes step-by-step.
It uses a syntax similar to the <a class="reference external" href="https://www.w3.org/TR/SVG/paths.html">SVG path specification</a>.</p>
<p>A short summary of the available methods is presented below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Primitive</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>L/l</p></td>
<td><p>Line segments</p></td>
</tr>
<tr class="row-odd"><td><p>H/h</p></td>
<td><p>Horizontal line segments</p></td>
</tr>
<tr class="row-even"><td><p>V/v</p></td>
<td><p>Vertical line segments</p></td>
</tr>
<tr class="row-odd"><td><p>C/c</p></td>
<td><p>Cubic Bezier curve</p></td>
</tr>
<tr class="row-even"><td><p>S/s</p></td>
<td><p>Smooth cubic Bezier curve</p></td>
</tr>
<tr class="row-odd"><td><p>Q/q</p></td>
<td><p>Quadratic Bezier curve</p></td>
</tr>
<tr class="row-even"><td><p>T/t</p></td>
<td><p>Smooth quadratic Bezier curve</p></td>
</tr>
<tr class="row-odd"><td><p>B/b</p></td>
<td><p>General degree Bezier curve</p></td>
</tr>
<tr class="row-even"><td><p>I/i</p></td>
<td><p>Smooth interpolating curve</p></td>
</tr>
<tr class="row-odd"><td><p>arc</p></td>
<td><p>Elliptical arc</p></td>
</tr>
</tbody>
</table>
<p>The uppercase version of the methods considers that all coordinates are absolute, whereas the lowercase considers that they are relative to the current end point of the curve.
Except for <a class="reference internal" href="reference.html#gdspy.Curve.I" title="gdspy.Curve.I"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Curve.I()</span></code></a>, <a class="reference internal" href="reference.html#gdspy.Curve.i" title="gdspy.Curve.i"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Curve.i()</span></code></a> and <a class="reference internal" href="reference.html#gdspy.Curve.arc" title="gdspy.Curve.arc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Curve.arc()</span></code></a>, they accept variable numbers of arguments that are used as coordinates to construct the primitive.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Construct a curve made of a sequence of line segments</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>

<span class="c1"># Construct another curve using relative coordinates</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>
</pre></div>
</div>
<img alt="_images/curves.svg" class="align-center" src="_images/curves.svg" /><p>Coordinate pairs can be given as a complex number: real and imaginary parts are used as x and y coordinates, respectively.
That is useful to define points in polar coordinates.</p>
<p>Elliptical arcs have syntax similar to <a class="reference internal" href="reference.html#gdspy.Round" title="gdspy.Round"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Round</span></code></a>, but they allow for an extra rotation of the major axis of the ellipse.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use complex numbers to facilitate writing polar coordinates</span>
<span class="n">c3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># Elliptical arcs have syntax similar to gdspy.Round</span>
<span class="n">c3</span><span class="o">.</span><span class="n">arc</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">p3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">c3</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>
</pre></div>
</div>
<img alt="_images/curves_1.svg" class="align-center" src="_images/curves_1.svg" /><p>Other curves can be constructed as cubic, quadratic and general-degree Bezier curves.
Additionally, a smooth interpolating curve can be calculated with the methods <a class="reference internal" href="reference.html#gdspy.Curve.I" title="gdspy.Curve.I"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Curve.I()</span></code></a> and <a class="reference internal" href="reference.html#gdspy.Curve.i" title="gdspy.Curve.i"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Curve.i()</span></code></a>, which have a number of arguments to control the shape of the curve.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Cubic Bezier curves can be easily created with C and c</span>
<span class="n">c4</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># Smooth continuation with S or s</span>
<span class="n">c4</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">p4</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">c4</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>

<span class="c1"># Similarly for quadratic Bezier curves</span>
<span class="n">c5</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">p5</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">c5</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>

<span class="c1"># Smooth interpolating curves can be built using I or i, including</span>
<span class="c1"># closed shapes</span>
<span class="n">c6</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">cycle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">p6</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">c6</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>
</pre></div>
</div>
<img alt="_images/curves_2.svg" class="align-center" src="_images/curves_2.svg" /></div>
<div class="section" id="transformations">
<h3>Transformations<a class="headerlink" href="#transformations" title="Permalink to this headline">¶</a></h3>
<p>All polygons can be transformed trough <a class="reference internal" href="reference.html#gdspy.PolygonSet.translate" title="gdspy.PolygonSet.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.PolygonSet.translate()</span></code></a>, <a class="reference internal" href="reference.html#gdspy.PolygonSet.rotate" title="gdspy.PolygonSet.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.PolygonSet.rotate()</span></code></a>, <a class="reference internal" href="reference.html#gdspy.PolygonSet.scale" title="gdspy.PolygonSet.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.PolygonSet.scale()</span></code></a>, and <a class="reference internal" href="reference.html#gdspy.PolygonSet.mirror" title="gdspy.PolygonSet.mirror"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.PolygonSet.mirror()</span></code></a>.
The transformations are applied in-place, i.e., no polygons are created.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">poly</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">poly</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">poly</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/transformations.svg" class="align-center" src="_images/transformations.svg" /></div>
<div class="section" id="layer-and-datatype">
<h3>Layer and Datatype<a class="headerlink" href="#layer-and-datatype" title="Permalink to this headline">¶</a></h3>
<p>All shapes in the GDSII format are tagged with 2 properties: layer and datatype (or texttype in the case of <a class="reference internal" href="reference.html#gdspy.Label" title="gdspy.Label"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Label</span></code></a>).
They are always 0 by default, but can be any integer in the range from 0 to 255.</p>
<p>These properties have no predefined meaning.
It is up to the system using the GDSII file to chose with to do with those tags.
For example, in the CMOS fabrication process, each layer could represent a different lithography level.</p>
<p>In the example below, a single file stores different fabrication masks in separate layer and datatype configurations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Layer/datatype definitions for each step in the fabrication</span>
<span class="n">ld_fulletch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;datatype&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">ld_partetch</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;datatype&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">ld_liftoff</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;datatype&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">}</span>

<span class="n">p1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="o">**</span><span class="n">ld_fulletch</span><span class="p">)</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="o">**</span><span class="n">ld_partetch</span><span class="p">)</span>
<span class="n">p3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="o">**</span><span class="n">ld_partetch</span><span class="p">)</span>
<span class="n">p4</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="o">**</span><span class="n">ld_liftoff</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/layer_and_datatype.svg" class="align-center" src="_images/layer_and_datatype.svg" /></div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>References give the GDSII format its hierarchical features.
They work by reusing a cell content in another cell (without actually copying the whole geometry).
As a simplistic example, imagine the we are designing a simple electronic circuit that uses hundreds of transistors, but they all have the same shape.
We can draw the transistor just once and reference it throughout the circuit, rotating or mirroring each instance as necessary.</p>
<p>Besides creating single references with <a class="reference internal" href="reference.html#gdspy.CellReference" title="gdspy.CellReference"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.CellReference</span></code></a>, it is possible to create full 2D arrays with a single entity using <a class="reference internal" href="reference.html#gdspy.CellArray" title="gdspy.CellArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.CellArray</span></code></a>.
Both are exemplified below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a cell with a component that is used repeatedly</span>
<span class="n">contact</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;CONTACT&quot;</span><span class="p">)</span>
<span class="n">contact</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">])</span>

<span class="c1"># Create a cell with the complete device</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;DEVICE&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span>
<span class="c1"># Add 2 references to the component changing size and orientation</span>
<span class="n">ref1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">CellReference</span><span class="p">(</span><span class="n">contact</span><span class="p">,</span> <span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="n">ref2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">CellReference</span><span class="p">(</span><span class="n">contact</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">),</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="n">device</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">ref1</span><span class="p">,</span> <span class="n">ref2</span><span class="p">])</span>

<span class="c1"># The final layout has several repetitions of the complete device</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;MAIN&quot;</span><span class="p">)</span>
<span class="n">main</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellArray</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
</pre></div>
</div>
<img alt="_images/references.svg" class="align-center" src="_images/references.svg" /></div>
<div class="section" id="paths">
<h2>Paths<a class="headerlink" href="#paths" title="Permalink to this headline">¶</a></h2>
<p>Besides polygons, the GDSII format defines paths, witch are <a class="reference external" href="https://en.wikipedia.org/wiki/Polygonal_chain">polygonal chains</a> with associated width and end caps.
The width is a single number, constant throughout the path, and the end caps can be flush, round, or extended by a custom distance.</p>
<p>There is no specification for the joins between adjacent segments, so it is up to the system using the GDSII file to specify those.
Usually the joins are straight extensions of the path boundaries up to some beveling limit.
Gdspy also uses this specification for the joins.</p>
<p>It is possible to circumvent all of the above limitations within gdspy by storing paths as polygons in the GDSII file.
The disadvantage of this solution is that other software will not be able to edit the geometry as paths, since that information is lost.</p>
<p>The construction of paths (either GDSII paths or polygonal paths) in gdspy is quite rich.
There are 3 classes that can be used depending on the requirements of the desired path.</p>
<div class="section" id="polygonal-only-paths">
<h3>Polygonal-Only Paths<a class="headerlink" href="#polygonal-only-paths" title="Permalink to this headline">¶</a></h3>
<p>The class <a class="reference internal" href="reference.html#gdspy.Path" title="gdspy.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Path</span></code></a> is designed to allow the creation of path-like polygons in a piece-wise manner.
It is the most computationally efficient class between the three because it <em>does not</em> calculate joins.
That means the user is responsible for designing the joins.
The paths can end up with discontinuities if care is not taken when creating them.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start a path at (0, 0) with width 1</span>
<span class="n">path1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Add a segment to the path goin in the &#39;+y&#39; direction</span>
<span class="n">path1</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;+y&quot;</span><span class="p">)</span>

<span class="c1"># Further segments or turns will folow the current path direction</span>
<span class="c1"># to ensure continuity</span>
<span class="n">path1</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">path1</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">path1</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;rr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/polygonal-only_paths.svg" class="align-center" src="_images/polygonal-only_paths.svg" /><p>Just as with <a class="reference internal" href="#circles"><span class="std std-ref">Circles</span></a>, all curved geometry is approximated by line segments.
The number of segments is similarly controlled by a <cite>tolerance</cite> or a <cite>number_of_points</cite> argument.
Curves also include fracturing to limit the number of points in each polygon.</p>
<p>More complex paths can be constructed with the methods <a class="reference internal" href="reference.html#gdspy.Path.bezier" title="gdspy.Path.bezier"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Path.bezier()</span></code></a>, <a class="reference internal" href="reference.html#gdspy.Path.smooth" title="gdspy.Path.smooth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Path.smooth()</span></code></a>, and <a class="reference internal" href="reference.html#gdspy.Path.parametric" title="gdspy.Path.parametric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Path.parametric()</span></code></a>.
The example below demonstrates a couple of possibilities.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">path2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Start the path with a smooth Bezier S-curve</span>
<span class="n">path2</span><span class="o">.</span><span class="n">bezier</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>

<span class="c1"># We want to add a spiral curve to the path.  The spiral is defined</span>
<span class="c1"># as a parametric curve.  We make sure spiral(0) = (0, 0) so that</span>
<span class="c1"># the path is continuous.</span>
<span class="k">def</span> <span class="nf">spiral</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">u</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># It is recommended to also define the derivative of the parametric</span>
<span class="c1"># curve, otherwise this derivative must be calculated nummerically.</span>
<span class="c1"># The derivative is used to define the side boundaries of the path,</span>
<span class="c1"># so, in this case, to ensure continuity with the existing S-curve,</span>
<span class="c1"># we make sure the the direction at the start of the spiral is</span>
<span class="c1"># pointing exactly upwards, as if is radius were constant.</span>
<span class="c1"># Additionally, the exact magnitude of the derivative is not</span>
<span class="c1"># important; gdspy only uses its direction.</span>
<span class="k">def</span> <span class="nf">dspiral_dt</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">dx_dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">dy_dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">dx_dt</span><span class="p">,</span> <span class="n">dy_dt</span><span class="p">)</span>

<span class="c1"># Add the parametric spiral to the path</span>
<span class="n">path2</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span><span class="n">spiral</span><span class="p">,</span> <span class="n">dspiral_dt</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/polygonal-only_paths_1.svg" class="align-center" src="_images/polygonal-only_paths_1.svg" /><p>The width of the path does not have to be constant.
Each path component can linearly taper the width of the path by using the <cite>final_width</cite> argument.
In the case of a parametric curve, more complex width changes can be created by setting <cite>final_width</cite> to a function.</p>
<p>Finally, parallel paths can be created simultaneously with the help of arguments <cite>number_of_paths</cite>, <cite>distance</cite>, and <cite>final_distance</cite>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start 3 parallel paths with center-to-center distance of 1.5</span>
<span class="n">path3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">number_of_paths</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

<span class="c1"># Add a segment tapering the widths up to 0.5</span>
<span class="n">path3</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;-y&quot;</span><span class="p">,</span> <span class="n">final_width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Add a bezier curve decreasing the distance between paths to 0.75</span>
<span class="n">path3</span><span class="o">.</span><span class="n">bezier</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)],</span> <span class="n">final_distance</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>

<span class="c1"># Add a parametric section to modulate the width with a sinusoidal</span>
<span class="c1"># shape.  Note that the algorithm that determines the number of</span>
<span class="c1"># evaluations of the parametric curve does not take the width into</span>
<span class="c1"># consideration, so we have to manually increase this parameter.</span>
<span class="n">path3</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">final_width</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">),</span>
    <span class="n">number_of_evaluations</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Add a circular turn and a final tapering segment.</span>
<span class="n">path3</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">)</span>
<span class="n">path3</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">final_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">final_distance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

</pre></div>
</div>
<img alt="_images/polygonal-only_paths_2.svg" class="align-center" src="_images/polygonal-only_paths_2.svg" /></div>
<div class="section" id="flexible-paths">
<h3>Flexible Paths<a class="headerlink" href="#flexible-paths" title="Permalink to this headline">¶</a></h3>
<p>Although very efficient, <a class="reference internal" href="reference.html#gdspy.Path" title="gdspy.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Path</span></code></a> is limited in the type of path it can provide.
For example, if we simply want a path going through a sequence of points, we need a class that can correctly compute the joins between segments.
That’s one of the advantages of class <a class="reference internal" href="reference.html#gdspy.FlexPath" title="gdspy.FlexPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.FlexPath</span></code></a>.
Other path construction methods are similar to those in <a class="reference internal" href="reference.html#gdspy.Path" title="gdspy.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Path</span></code></a>.</p>
<p>A few features of <a class="reference internal" href="reference.html#gdspy.FlexPath" title="gdspy.FlexPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.FlexPath</span></code></a> are:</p>
<ul class="simple">
<li><p>paths can be stored as proper GDSII paths;</p></li>
<li><p>end caps and joins can be specified by the user;</p></li>
<li><p>each parallel path can have a different width;</p></li>
<li><p>spacing between parallel paths is arbitrary; the user specifies the offset of each path individually.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Path defined by a sequence of points and stored as a GDSII path</span>
<span class="n">sp1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span>
    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gdsii_path</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Other construction methods can still be used</span>
<span class="n">sp1</span><span class="o">.</span><span class="n">smooth</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Multiple parallel paths separated by 0.5 with different widths,</span>
<span class="c1"># end caps, and joins.  Because of the join specification, they</span>
<span class="c1"># cannot be stared as GDSII paths, only as polygons.</span>
<span class="n">sp2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span>
    <span class="p">[(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
    <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">ends</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;extended&quot;</span><span class="p">,</span> <span class="s2">&quot;flush&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">],</span>
    <span class="n">corners</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;bevel&quot;</span><span class="p">,</span> <span class="s2">&quot;miter&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">sp2</span><span class="o">.</span><span class="n">arc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">sp2</span><span class="o">.</span><span class="n">arc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/flexible_paths.svg" class="align-center" src="_images/flexible_paths.svg" /><p>The following example shows other features, such as width tapering, arbitrary offsets, and custom joins and end caps.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Path corners and end caps can be custom functions.</span>
<span class="c1"># This corner function creates &#39;broken&#39; joins.</span>
<span class="k">def</span> <span class="nf">broken</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="c1"># Calculate intersection point p between lines defined by</span>
    <span class="c1"># p0 + u0 * v0 (for all u0) and p1 + u1 * v1 (for all u1)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">lim</span> <span class="o">=</span> <span class="mf">1e-12</span> <span class="o">*</span> <span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">v0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">den</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">:</span>
        <span class="c1"># Lines are parallel: use mid-point</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">u1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">p1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span> <span class="o">/</span> <span class="n">den</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">v0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span> <span class="o">/</span> <span class="n">den</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">v0</span> <span class="o">*</span> <span class="n">u0</span> <span class="o">+</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">u1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u0</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">u1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Inner corner</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="c1"># Outer corner</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">]</span>

<span class="c1"># This end cap function creates pointy caps.</span>
<span class="k">def</span> <span class="nf">pointy</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">v0</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">v1</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">p1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v0</span> <span class="o">-</span> <span class="n">v1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">p1</span><span class="p">]</span>

<span class="c1"># Paths with arbitrary offsets from the center and multiple layers.</span>
<span class="n">sp3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span>
    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
    <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
    <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="n">layer</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="n">corners</span><span class="o">=</span><span class="n">broken</span><span class="p">,</span>
    <span class="n">ends</span><span class="o">=</span><span class="n">pointy</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">sp3</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">sp3</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="n">sp3</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/flexible_paths_1.svg" class="align-center" src="_images/flexible_paths_1.svg" /><p>The corner type ‘circular bend’ (together with the <cite>bend_radius</cite> argument) can be used to automatically curve the path.
This feature is used in <span class="xref std std-ref">Example: Integrated Photonics</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Path created with automatic bends of radius 5</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)]</span>
<span class="n">sp4</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span>
    <span class="n">points</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">corners</span><span class="o">=</span><span class="s2">&quot;circular bend&quot;</span><span class="p">,</span> <span class="n">bend_radius</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">gdsii_path</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Same path, generated with natural corners, for comparison</span>
<span class="n">sp5</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gdsii_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/flexible_paths_2.svg" class="align-center" src="_images/flexible_paths_2.svg" /></div>
<div class="section" id="robust-paths">
<h3>Robust Paths<a class="headerlink" href="#robust-paths" title="Permalink to this headline">¶</a></h3>
<p>In some situations, <a class="reference internal" href="reference.html#gdspy.FlexPath" title="gdspy.FlexPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.FlexPath</span></code></a> is unable to properly calculate all the joins.
This often happens when the width or offset of the path is relatively large with respect to the length of the segments being joined.
Curves that join other curves or segments at sharp angles are an example of such situation.</p>
<p>The class <a class="reference internal" href="reference.html#gdspy.RobustPath" title="gdspy.RobustPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.RobustPath</span></code></a> can be used in such scenarios where robustness is more important than efficiency due to sharp corners or large offsets in the paths.
The drawbacks of using <a class="reference internal" href="reference.html#gdspy.RobustPath" title="gdspy.RobustPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.RobustPath</span></code></a> are the loss in computation efficiency (compared to the other 2 classes) and the impossibility of specifying corner shapes.
The advantages are, as mentioned earlier, more robustness when generating the final geometry, and freedom to use custom functions to parameterize the widths or offsets of the paths in any construction method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create 4 parallel paths in different layers</span>
<span class="n">lp</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">RobustPath</span><span class="p">(</span>
    <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">ends</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;extended&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="s2">&quot;flush&quot;</span><span class="p">,</span> <span class="s2">&quot;flush&quot;</span><span class="p">],</span>
    <span class="n">layer</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">lp</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">45</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">lp</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">width</span><span class="o">=</span><span class="p">[</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">offset</span><span class="o">=</span><span class="p">[</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">)</span>
<span class="n">lp</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">lp</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span>
    <span class="p">[(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
    <span class="n">angles</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">lp</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">45</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">))),</span>
    <span class="n">offset</span><span class="o">=</span><span class="p">[</span>
        <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">),</span>
        <span class="o">-</span><span class="mf">0.75</span><span class="p">,</span>
        <span class="mf">0.75</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<img alt="_images/robust_paths.svg" class="align-center" src="_images/robust_paths.svg" /><p>Note that, analogously to <a class="reference internal" href="reference.html#gdspy.FlexPath" title="gdspy.FlexPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.FlexPath</span></code></a>, <a class="reference internal" href="reference.html#gdspy.RobustPath" title="gdspy.RobustPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.RobustPath</span></code></a> can be stored as a GDSII path as long as its width is kept constant.</p>
</div>
</div>
<div class="section" id="text">
<h2>Text<a class="headerlink" href="#text" title="Permalink to this headline">¶</a></h2>
<p>In the context of a GDSII file, text is supported in the form of labels, which are ASCII annotations placed somewhere in the geometry of a given cell.
Similar to polygons, labels are tagged with layer and texttype values (texttype is the label equivalent of the polygon datatype).
They are supported by the class <a class="reference internal" href="reference.html#gdspy.Label" title="gdspy.Label"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Label</span></code></a>.</p>
<p>Additionally, gdspy offers the possibility of creating text as polygons to be included with the geometry.
The class <a class="reference internal" href="reference.html#gdspy.Text" title="gdspy.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.Text</span></code></a> creates polygonal text that can be used in the same way as any other polygons in gdspy.
The font used to render the characters contains only horizontal and vertical edges, which is important for some laser writing systems.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Label anchored at (1, 3) by its north-west corner</span>
<span class="n">label</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s2">&quot;Sample label&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;nw&quot;</span><span class="p">)</span>

<span class="c1"># Horizontal text with height 2.25</span>
<span class="n">htext</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s2">&quot;12345&quot;</span><span class="p">,</span> <span class="mf">2.25</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Vertical text with height 1.5</span>
<span class="n">vtext</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s2">&quot;ABC&quot;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="p">(</span><span class="mf">10.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">horizontal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">rect</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/text.svg" class="align-center" src="_images/text.svg" /></div>
<div class="section" id="geometry-operations">
<h2>Geometry Operations<a class="headerlink" href="#geometry-operations" title="Permalink to this headline">¶</a></h2>
<p>Gdspy offers a number of functions and methods to modify existing geometry.
The most useful operations include <a class="reference internal" href="reference.html#gdspy.boolean" title="gdspy.boolean"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.boolean()</span></code></a>, <a class="reference internal" href="reference.html#gdspy.slice" title="gdspy.slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.slice()</span></code></a>, <a class="reference internal" href="reference.html#gdspy.offset" title="gdspy.offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.offset()</span></code></a>, and <a class="reference internal" href="reference.html#gdspy.PolygonSet.fillet" title="gdspy.PolygonSet.fillet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.PolygonSet.fillet()</span></code></a>.</p>
<div class="section" id="boolean-operations">
<h3>Boolean Operations<a class="headerlink" href="#boolean-operations" title="Permalink to this headline">¶</a></h3>
<p>Boolean operations (<a class="reference internal" href="reference.html#gdspy.boolean" title="gdspy.boolean"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.boolean()</span></code></a>) can be performed on polygons, paths and whole cells.
Four operations are defined: union (‘or’), intersection (‘and’), subtraction (‘not’), and symmetric subtraction (‘xor’).</p>
<p>They can be computationally expensive, so it is usually advisable to avoid using boolean operations whenever possible.
If they are necessary, keeping the number of vertices is all polygons as low as possible also helps.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create some text</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s2">&quot;GDSPY&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1"># Create a rectangle extending the text&#39;s bounding box by 1</span>
<span class="n">bb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">get_bounding_box</span><span class="p">())</span>
<span class="n">rect</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Subtract the text from the rectangle</span>
<span class="n">inv</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="s2">&quot;not&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/boolean_operations.svg" class="align-center" src="_images/boolean_operations.svg" /></div>
<div class="section" id="slice-operation">
<h3>Slice Operation<a class="headerlink" href="#slice-operation" title="Permalink to this headline">¶</a></h3>
<p>As the name indicates, a slice operation subdivides a set of polygons along horizontal or vertical cut lines.</p>
<p>In a few cases, a boolean operation can be substituted by one or more slice operations.
Because <a class="reference internal" href="reference.html#gdspy.slice" title="gdspy.slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.slice()</span></code></a> is ususally much simpler than <a class="reference internal" href="reference.html#gdspy.boolean" title="gdspy.boolean"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.boolean()</span></code></a>, it is a good idea to use the former if possible.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ring1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">6</span><span class="p">,</span> <span class="n">inner_radius</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">ring2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">6</span><span class="p">,</span> <span class="n">inner_radius</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">ring3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">6</span><span class="p">,</span> <span class="n">inner_radius</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Slice the first ring across x=-3, the second ring across x=-3</span>
<span class="c1"># and x=3, and the third ring across x=3</span>
<span class="n">slices1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ring1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">slices2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ring2</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">slices3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ring3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">slices</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;SLICES&quot;</span><span class="p">)</span>

<span class="c1"># Keep only the left side of slices1, the center part of slices2</span>
<span class="c1"># and the right side of slices3</span>
<span class="n">slices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">slices1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">slices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">slices2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">slices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">slices3</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

</pre></div>
</div>
<img alt="_images/slice_operation.svg" class="align-center" src="_images/slice_operation.svg" /></div>
<div class="section" id="offset-operation">
<h3>Offset Operation<a class="headerlink" href="#offset-operation" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="reference.html#gdspy.offset" title="gdspy.offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.offset()</span></code></a> expands or contracts polygons by a fixed amount.
It can operate on individual polygons or sets of them, in which case it may make sense to use the argument <cite>join_first</cite> to operate on the whole geometry as if a boolean ‘or’ was executed beforehand.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rect1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">rect2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1"># Offset both polygons</span>
<span class="c1"># Because we join them first, a single polygon is created.</span>
<span class="n">outer</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">offset</span><span class="p">([</span><span class="n">rect1</span><span class="p">,</span> <span class="n">rect2</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">join_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/offset_operation.svg" class="align-center" src="_images/offset_operation.svg" /></div>
<div class="section" id="fillet-operation">
<h3>Fillet Operation<a class="headerlink" href="#fillet-operation" title="Permalink to this headline">¶</a></h3>
<p>The method <a class="reference internal" href="reference.html#gdspy.PolygonSet.fillet" title="gdspy.PolygonSet.fillet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.PolygonSet.fillet()</span></code></a> can be used to round polygon corners.
It doesn’t have a <cite>join_first</cite> argument as <a class="reference internal" href="reference.html#gdspy.offset" title="gdspy.offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">gdspy.offset()</span></code></a>, so if it will be used on a polygon, that polygon should probably not be fractured.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">multi_path</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="n">multi_path</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;+x&quot;</span><span class="p">)</span>
<span class="n">multi_path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">multi_path</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Create a copy with joined polygons and no fracturing</span>
<span class="n">joined</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="n">multi_path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">max_points</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">joined</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fillet applied to each polygon in the path</span>
<span class="n">multi_path</span><span class="o">.</span><span class="n">fillet</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Fillet applied to the joined copy</span>
<span class="n">joined</span><span class="o">.</span><span class="n">fillet</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/fillet_operation.svg" class="align-center" src="_images/fillet_operation.svg" /></div>
</div>
<div class="section" id="gdsii-library">
<h2>GDSII Library<a class="headerlink" href="#gdsii-library" title="Permalink to this headline">¶</a></h2>
<p>All the information used to create a GDSII file is kept within an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">GdsLibrary</span></code>.
Besides all the geometric and hierarchical information, this class also holds a name and the units for all entities.
The name can be any ASCII string.
It is simply stored in the GDSII file and has no other purpose in gdspy.
The units require some attention because they can impact the resolution of the polygons in the library when written to a file.</p>
<div class="section" id="units-in-gdsii">
<h3>Units in GDSII<a class="headerlink" href="#units-in-gdsii" title="Permalink to this headline">¶</a></h3>
<p>Two values are defined: <cite>unit</cite> and <cite>precision</cite>.
The value of <cite>unit</cite> defines the unit size—in meters—for all entities in the library.
For example, if <code class="docutils literal notranslate"><span class="pre">unit</span> <span class="pre">=</span> <span class="pre">1e-6</span></code> (10⁻⁶ m, the default value), a vertex at (1, 2) should be interpreted as a vertex in real world position (1 × 10⁻⁶ m, 2 × 10⁻⁶ m).
If <cite>unit</cite> changes to 0.001, then that same vertex would be located (in real world coordinates) at (0.001 m, 0.002 m), or (1 mm, 2 mm).</p>
<p>The value of precision has to do with the type used to store coordinates in the GDSII file: signed 4-byte integers.
Because of that, a finer coordinate grid than 1 <cite>unit</cite> is usually desired to define coordinates.
That grid is defined, in meters, by <cite>precision</cite>, which defaults to <code class="docutils literal notranslate"><span class="pre">1e-9</span></code> (10⁻⁹ m).
When the GDSII file is written, all vertices are snapped to the grid defined by <cite>precision</cite>.
For example, for the default values of <cite>unit</cite> and <cite>precision</cite>, a vertex at (1.0512, 0.0001) represents real world coordinates (1.0512 × 10⁻⁶ m, 0.0001 × 10⁻⁶ m), or (1051.2 × 10⁻⁹ m, 0.1 × 10⁻⁹ m), which will be rounded to integers: (1051 × 10⁻⁹ m, 0 × 10⁻⁹ m), or (1.051 × 10⁻⁶ m, 0 × 10⁻⁶ m).
The actual coordinate values written in the GDSII file will be the integers (1051, 0).
By reducing the value of <cite>precision</cite> from 10⁻⁹ m to 10⁻¹² m, for example, the coordinates will have 3 additional decimal places of precision, so the stored values would be (1051200, 100).</p>
<p>The downside of increasing the number of decimal places in the file is reducing the range of coordinates that can be stored (in real world units).
That is because the range of coordinate values that can be written in the file are [-(2³²); 2³¹ - 1] = [-2,147,483,648; 2,147,483,647].
For the default <cite>precsision</cite>, this range is [-2.147483648 m; 2.147483647 m].
If <cite>precision</cite> is set to 10⁻¹² m, the same range is reduced by 1000 times: [-2.147483648 mm; 2.147483647 mm].</p>
</div>
<div class="section" id="saving-a-gdsii-file">
<h3>Saving a GDSII File<a class="headerlink" href="#saving-a-gdsii-file" title="Permalink to this headline">¶</a></h3>
<p>To save a GDSII file, simply use the <a class="reference internal" href="reference.html#gdspy.GdsLibrary.write_gds" title="gdspy.GdsLibrary.write_gds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.GdsLibrary.write_gds()</span></code></a> method, as in the <a class="reference internal" href="#first-gdsii"><span class="std std-ref">First GDSII</span></a>.</p>
<p>An SVG image from a specific cell can also be exported through <a class="reference internal" href="reference.html#gdspy.Cell.write_svg" title="gdspy.Cell.write_svg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.Cell.write_svg()</span></code></a>, which was also demonstrated in <a class="reference internal" href="#first-gdsii"><span class="std std-ref">First GDSII</span></a>.</p>
</div>
<div class="section" id="loading-a-gdsii-file">
<h3>Loading a GDSII File<a class="headerlink" href="#loading-a-gdsii-file" title="Permalink to this headline">¶</a></h3>
<p>To load an existing GDSII file (or to work simultaneously with multiple libraries), a new instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">GdsLibrary</span></code> can be created or an existing one can be used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load a GDSII file into a new library</span>
<span class="n">gdsii</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">GdsLibrary</span><span class="p">(</span><span class="n">infile</span><span class="o">=</span><span class="s1">&#39;filename.gds&#39;</span><span class="p">)</span>

<span class="c1"># Use a previously-created library to load the file contents into</span>
<span class="n">existing_library</span><span class="o">.</span><span class="n">read_gds</span><span class="p">(</span><span class="s1">&#39;filename.gds&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In either case, care must be taken to merge the units from the library and the file, which is controlled by the argument <cite>units</cite> in <a class="reference internal" href="reference.html#gdspy.GdsLibrary.read_gds" title="gdspy.GdsLibrary.read_gds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.GdsLibrary.read_gds()</span></code></a> (keyword argument in <a class="reference internal" href="reference.html#gdspy.GdsLibrary" title="gdspy.GdsLibrary"><code class="xref py py-class docutils literal notranslate"><span class="pre">gdspy.GdsLibrary</span></code></a>).</p>
<p>Access to the cells in the loaded library is provided through the dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">gdspy.GdsLibrary.cell_dict</span></code> (cells indexed by name).
The method <a class="reference internal" href="reference.html#gdspy.GdsLibrary.top_level" title="gdspy.GdsLibrary.top_level"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gdspy.GdsLibrary.top_level()</span></code></a> can be used to find the top-level cells in the library (cells on the top of the hierarchy, i.e., cell that are not referenced by any other cells).</p>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integrated-photonics">
<h3>Integrated Photonics<a class="headerlink" href="#integrated-photonics" title="Permalink to this headline">¶</a></h3>
<p>This example demonstrates the use of gdspy primitives to create more complex structures.</p>
<p>These structures are commonly used in the field of integrated photonics.</p>
<p><a class="reference download internal" download="" href="_downloads/488613e368b36f9fae1f453b83e98d40/photonics.py"><code class="xref download docutils literal notranslate"><span class="pre">photonics.py</span></code></a></p>
<p><a class="reference download internal" download="" href="_downloads/5a8b2123c339221aec5820c5cb4dd018/photonics.gds"><code class="xref download docutils literal notranslate"><span class="pre">photonics.gds</span></code></a></p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">######################################################################</span>
<span class="c1">#                                                                    #</span>
<span class="c1">#  Copyright 2009-2020 Lucas Heitzmann Gabrielli.                    #</span>
<span class="c1">#  This file is part of gdspy, distributed under the terms of the    #</span>
<span class="c1">#  Boost Software License - Version 1.0.  See the accompanying       #</span>
<span class="c1">#  LICENSE file or &lt;http://www.boost.org/LICENSE_1_0.txt&gt;            #</span>
<span class="c1">#                                                                    #</span>
<span class="c1">######################################################################</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">gdspy</span>


<span class="k">def</span> <span class="nf">grating</span><span class="p">(</span>
    <span class="n">period</span><span class="p">,</span>
    <span class="n">number_of_teeth</span><span class="p">,</span>
    <span class="n">fill_frac</span><span class="p">,</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">position</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">,</span>
    <span class="n">lda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">sin_theta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">focus_distance</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">focus_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">layer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">datatype</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Straight or focusing grating.</span>

<span class="sd">    period          : grating period</span>
<span class="sd">    number_of_teeth : number of teeth in the grating</span>
<span class="sd">    fill_frac       : filling fraction of the teeth (w.r.t. the period)</span>
<span class="sd">    width           : width of the grating</span>
<span class="sd">    position        : grating position (feed point)</span>
<span class="sd">    direction       : one of {&#39;+x&#39;, &#39;-x&#39;, &#39;+y&#39;, &#39;-y&#39;}</span>
<span class="sd">    lda             : free-space wavelength</span>
<span class="sd">    sin_theta       : sine of incidence angle</span>
<span class="sd">    focus_distance  : focus distance (negative for straight grating)</span>
<span class="sd">    focus_width     : if non-negative, the focusing area is included in</span>
<span class="sd">                      the result (usually for negative resists) and this</span>
<span class="sd">                      is the width of the waveguide connecting to the</span>
<span class="sd">                      grating</span>
<span class="sd">    tolerance       : same as in `path.parametric`</span>
<span class="sd">    layer           : GDSII layer number</span>
<span class="sd">    datatype        : GDSII datatype number</span>

<span class="sd">    Return `PolygonSet`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">focus_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">L1Path</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span>
                <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">number_of_teeth</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fill_frac</span><span class="p">)</span> <span class="o">*</span> <span class="n">period</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="s2">&quot;+x&quot;</span><span class="p">,</span>
            <span class="n">period</span> <span class="o">*</span> <span class="n">fill_frac</span><span class="p">,</span>
            <span class="p">[</span><span class="n">width</span><span class="p">],</span>
            <span class="p">[],</span>
            <span class="n">number_of_teeth</span><span class="p">,</span>
            <span class="n">period</span><span class="p">,</span>
            <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span>
            <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">neff</span> <span class="o">=</span> <span class="n">lda</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin_theta</span>
        <span class="n">qmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">focus_distance</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">period</span> <span class="o">*</span> <span class="n">fill_frac</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="n">neff</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">sin_theta</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">qmin</span><span class="p">,</span> <span class="n">qmin</span> <span class="o">+</span> <span class="n">number_of_teeth</span><span class="p">):</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">lda</span> <span class="o">*</span> <span class="n">sin_theta</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">lda</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">p</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">width</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">c1</span> <span class="o">+</span> <span class="n">neff</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c2</span> <span class="o">-</span> <span class="n">c3</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">c3</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="n">max_points</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span>
                <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">focus_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">sz</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span class="n">position</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">focus_width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">sz</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">focus_width</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">focus_width</span><span class="p">,</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">fracture</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;-x&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;+x&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;-y&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Examples</span>
    <span class="n">lib</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">GdsLibrary</span><span class="p">()</span>

    <span class="c1"># Negative resist example</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mf">0.45</span>
    <span class="n">bend_radius</span> <span class="o">=</span> <span class="mf">50.0</span>
    <span class="n">ring_radius</span> <span class="o">=</span> <span class="mf">20.0</span>
    <span class="n">taper_len</span> <span class="o">=</span> <span class="mf">50.0</span>
    <span class="n">input_gap</span> <span class="o">=</span> <span class="mf">150.0</span>
    <span class="n">io_gap</span> <span class="o">=</span> <span class="mf">500.0</span>
    <span class="n">wg_gap</span> <span class="o">=</span> <span class="mf">20.0</span>
    <span class="n">ring_gaps</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.06</span> <span class="o">+</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>

    <span class="n">ring</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;NRing&quot;</span><span class="p">)</span>
    <span class="n">ring</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="n">ring_radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ring_radius</span><span class="p">,</span> <span class="n">ring_radius</span> <span class="o">-</span> <span class="n">width</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">grat</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;NGrat&quot;</span><span class="p">)</span>
    <span class="n">grat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">grating</span><span class="p">(</span>
            <span class="mf">0.626</span><span class="p">,</span>
            <span class="mi">28</span><span class="p">,</span>
            <span class="mf">0.5</span><span class="p">,</span>
            <span class="mi">19</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;+y&quot;</span><span class="p">,</span>
            <span class="mf">1.55</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">/</span> <span class="mi">180</span><span class="p">),</span>
            <span class="mf">21.5</span><span class="p">,</span>
            <span class="n">width</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">taper</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;NTaper&quot;</span><span class="p">)</span>
    <span class="n">taper</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mf">0.12</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">taper_len</span><span class="p">,</span> <span class="s2">&quot;+y&quot;</span><span class="p">,</span> <span class="n">final_width</span><span class="o">=</span><span class="n">width</span><span class="p">))</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;Negative&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gap</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ring_gaps</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">input_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">taper_len</span><span class="p">)],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">corners</span><span class="o">=</span><span class="s2">&quot;circular bend&quot;</span><span class="p">,</span>
            <span class="n">bend_radius</span><span class="o">=</span><span class="n">bend_radius</span><span class="p">,</span>
            <span class="n">gdsii_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span> <span class="o">-</span> <span class="n">wg_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="n">io_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span> <span class="o">+</span> <span class="n">wg_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellReference</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="p">(</span><span class="n">input_gap</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">gap</span><span class="p">,</span> <span class="mi">300</span><span class="p">)))</span>
    <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellArray</span><span class="p">(</span><span class="n">taper</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring_gaps</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">input_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">gdspy</span><span class="o">.</span><span class="n">CellArray</span><span class="p">(</span>
            <span class="n">grat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring_gaps</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">input_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">io_gap</span><span class="p">,</span> <span class="mi">900</span> <span class="o">+</span> <span class="n">taper_len</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Positive resist example</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mf">0.45</span>
    <span class="n">ring_radius</span> <span class="o">=</span> <span class="mf">20.0</span>
    <span class="n">big_margin</span> <span class="o">=</span> <span class="mf">10.0</span>
    <span class="n">small_margin</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">taper_len</span> <span class="o">=</span> <span class="mf">50.0</span>
    <span class="n">bus_len</span> <span class="o">=</span> <span class="mf">400.0</span>
    <span class="n">input_gap</span> <span class="o">=</span> <span class="mf">150.0</span>
    <span class="n">io_gap</span> <span class="o">=</span> <span class="mf">500.0</span>
    <span class="n">wg_gap</span> <span class="o">=</span> <span class="mf">20.0</span>
    <span class="n">ring_gaps</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.06</span> <span class="o">+</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>

    <span class="n">ring_margin</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">ring_radius</span> <span class="o">-</span> <span class="n">big_margin</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ring_radius</span> <span class="o">+</span> <span class="n">big_margin</span><span class="p">,</span> <span class="n">ring_radius</span> <span class="o">+</span> <span class="n">big_margin</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">ring_hole</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">(</span>
        <span class="p">(</span><span class="n">ring_radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ring_radius</span><span class="p">,</span> <span class="n">ring_radius</span> <span class="o">-</span> <span class="n">width</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span>
    <span class="p">)</span>
    <span class="n">ring_bus</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span>
        <span class="n">small_margin</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">taper_len</span><span class="p">),</span> <span class="n">number_of_paths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">small_margin</span> <span class="o">+</span> <span class="n">width</span>
    <span class="p">)</span>
    <span class="n">ring_bus</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">bus_len</span><span class="p">,</span> <span class="s2">&quot;+y&quot;</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span>
        <span class="n">small_margin</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">number_of_paths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">small_margin</span> <span class="o">+</span> <span class="n">width</span>
    <span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mf">21.5</span><span class="p">,</span> <span class="s2">&quot;+y&quot;</span><span class="p">,</span> <span class="n">final_distance</span><span class="o">=</span><span class="n">small_margin</span> <span class="o">+</span> <span class="mi">19</span><span class="p">)</span>
    <span class="n">grat</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;PGrat&quot;</span><span class="p">)</span>
    <span class="n">grat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">grat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">grating</span><span class="p">(</span>
            <span class="mf">0.626</span><span class="p">,</span>
            <span class="mi">28</span><span class="p">,</span>
            <span class="mf">0.5</span><span class="p">,</span>
            <span class="mi">19</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;+y&quot;</span><span class="p">,</span>
            <span class="mf">1.55</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">/</span> <span class="mi">180</span><span class="p">),</span>
            <span class="mf">21.5</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">big_margin</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">number_of_paths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">big_margin</span> <span class="o">+</span> <span class="mf">0.12</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
        <span class="n">taper_len</span><span class="p">,</span> <span class="s2">&quot;+y&quot;</span><span class="p">,</span> <span class="n">final_width</span><span class="o">=</span><span class="n">small_margin</span><span class="p">,</span> <span class="n">final_distance</span><span class="o">=</span><span class="n">small_margin</span> <span class="o">+</span> <span class="n">width</span>
    <span class="p">)</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;PTaper&quot;</span><span class="p">)</span>
    <span class="n">taper</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;Positive&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gap</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ring_gaps</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">FlexPath</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">input_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">taper_len</span> <span class="o">+</span> <span class="n">bus_len</span><span class="p">)],</span>
            <span class="n">width</span><span class="o">=</span><span class="p">[</span><span class="n">small_margin</span><span class="p">,</span> <span class="n">small_margin</span><span class="p">],</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">small_margin</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span>
            <span class="n">gdsii_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span> <span class="o">-</span> <span class="n">bus_len</span> <span class="o">-</span> <span class="n">bend_radius</span> <span class="o">-</span> <span class="n">wg_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="n">bend_radius</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="n">io_gap</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bend_radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="n">bend_radius</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">segment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span> <span class="o">-</span> <span class="n">bend_radius</span> <span class="o">+</span> <span class="n">wg_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">gap</span>
        <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span>
                <span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span>
                    <span class="n">ring_bus</span><span class="p">,</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ring_margin</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">1e-4</span>
                <span class="p">),</span>
                <span class="n">gdspy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ring_hole</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span>
                <span class="s2">&quot;not&quot;</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">input_gap</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellArray</span><span class="p">(</span><span class="n">taper</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring_gaps</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">input_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">gdspy</span><span class="o">.</span><span class="n">CellArray</span><span class="p">(</span>
            <span class="n">grat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring_gaps</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">input_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">io_gap</span><span class="p">,</span> <span class="mi">900</span> <span class="o">+</span> <span class="n">taper_len</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Save to a gds file and check out the output</span>
    <span class="n">lib</span><span class="o">.</span><span class="n">write_gds</span><span class="p">(</span><span class="s2">&quot;photonics.gds&quot;</span><span class="p">)</span>
    <span class="n">gdspy</span><span class="o">.</span><span class="n">LayoutViewer</span><span class="p">(</span><span class="n">lib</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="using-system-fonts">
<h3>Using System Fonts<a class="headerlink" href="#using-system-fonts" title="Permalink to this headline">¶</a></h3>
<p>This example uses <a class="reference external" href="https://matplotlib.org/">matplotlib</a> to render text using any typeface present in the system.
The glyph paths are then transformed into polygon arrays that can be used to create <cite>gdspy.PolygonSet</cite> objects.</p>
<p><a class="reference download internal" download="" href="_downloads/135c0c362d763977fdad1d9729652b3c/fonts.py"><code class="xref download docutils literal notranslate"><span class="pre">fonts.py</span></code></a></p>
<p><a class="reference download internal" download="" href="_downloads/34e92fcdce088412b57581d604d16ba1/fonts.gds"><code class="xref download docutils literal notranslate"><span class="pre">fonts.gds</span></code></a></p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">######################################################################</span>
<span class="c1">#                                                                    #</span>
<span class="c1">#  Copyright 2009-2020 Lucas Heitzmann Gabrielli.                    #</span>
<span class="c1">#  This file is part of gdspy, distributed under the terms of the    #</span>
<span class="c1">#  Boost Software License - Version 1.0.  See the accompanying       #</span>
<span class="c1">#  LICENSE file or &lt;http://www.boost.org/LICENSE_1_0.txt&gt;            #</span>
<span class="c1">#                                                                    #</span>
<span class="c1">######################################################################</span>

<span class="kn">from</span> <span class="nn">matplotlib.font_manager</span> <span class="kn">import</span> <span class="n">FontProperties</span>
<span class="kn">from</span> <span class="nn">matplotlib.textpath</span> <span class="kn">import</span> <span class="n">TextPath</span>
<span class="kn">import</span> <span class="nn">gdspy</span>


<span class="k">def</span> <span class="nf">render_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">font_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">TextPath</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">prop</span><span class="o">=</span><span class="n">font_prop</span><span class="p">)</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">points</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">iter_segments</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">CURVE3</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">CURVE4</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">C</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">CLOSEPOLY</span><span class="p">:</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">poly</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span>
                            <span class="n">poly</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">tolerance</span>
                        <span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">polys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">poly</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">p</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">poly</span><span class="p">],</span>
                                <span class="s2">&quot;xor&quot;</span><span class="p">,</span>
                                <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">,</span>
                                <span class="n">max_points</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span>
                            <span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">poly</span><span class="p">],</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">tolerance</span>
                        <span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">polys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">poly</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">p</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">poly</span><span class="p">],</span>
                                <span class="s2">&quot;xor&quot;</span><span class="p">,</span>
                                <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">,</span>
                                <span class="n">max_points</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">poly</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">FontProperties</span><span class="p">(</span><span class="n">family</span><span class="o">=</span><span class="s2">&quot;serif&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;italic&quot;</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">PolygonSet</span><span class="p">(</span><span class="n">render_text</span><span class="p">(</span><span class="s2">&quot;Text rendering&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">font_prop</span><span class="o">=</span><span class="n">fp</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lib</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">GdsLibrary</span><span class="p">()</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">new_cell</span><span class="p">(</span><span class="s2">&quot;TXT&quot;</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">lib</span><span class="o">.</span><span class="n">write_gds</span><span class="p">(</span><span class="s2">&quot;fonts.gds&quot;</span><span class="p">)</span>
    <span class="n">gdspy</span><span class="o">.</span><span class="n">LayoutViewer</span><span class="p">(</span><span class="n">lib</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="reference.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Gdspy’s Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2009-2020, Lucas H. Gabrielli

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>