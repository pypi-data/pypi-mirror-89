/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_fltk_WRAP_H_
#define SWIG_fltk_WRAP_H_

#include <map>
#include <string>


class SwigDirector_Fl_Image : public Fl_Image, public Swig::Director {

public:
    SwigDirector_Fl_Image(PyObject *self, int W, int H, int D);
    virtual ~SwigDirector_Fl_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_RGB_Image : public Fl_RGB_Image, public Swig::Director {

public:
    SwigDirector_Fl_RGB_Image(PyObject *self, uchar const *bits, int W, int H, int D = 3, int LD = 0);
    SwigDirector_Fl_RGB_Image(PyObject *self, Fl_Pixmap const *pxm, Fl_Color bg = FL_BACKGROUND_COLOR);
    virtual ~SwigDirector_Fl_RGB_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_RGB_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Widget : public Fl_Widget, public Swig::Director {

public:
    SwigDirector_Fl_Widget(PyObject *self, int x, int y, int w, int h, char const *label = 0L);
    virtual ~SwigDirector_Fl_Widget();
    virtual void draw();
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Widget doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Group : public Fl_Group, public Swig::Director {

public:
    SwigDirector_Fl_Group(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Group();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Group doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Browser_ : public Fl_Browser_, public Swig::Director {

public:
    SwigDirector_Fl_Browser_(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Browser_();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_next(void *item) const;
    virtual void *item_prev(void *item) const;
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser_::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_width(void *item) const;
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser_::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser_::item_swap(a,b);
    }
    virtual void *item_at(int index) const;
    virtual void *item_atSwigPublic(int index) const {
      return Fl_Browser_::item_at(index);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser_::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser_::incr_height();
    }
    virtual void item_select(void *item, int val = 1);
    virtual void item_selectSwigPublic(void *item, int val = 1) {
      Fl_Browser_::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser_::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Browser_ doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_Browser : public Fl_Browser, public Swig::Director {

public:
    SwigDirector_Fl_Browser(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Browser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_firstSwigPublic() const {
      return Fl_Browser::item_first();
    }
    virtual void *item_next(void *item) const;
    virtual void *item_nextSwigPublic(void *item) const {
      return Fl_Browser::item_next(item);
    }
    virtual void *item_prev(void *item) const;
    virtual void *item_prevSwigPublic(void *item) const {
      return Fl_Browser::item_prev(item);
    }
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_heightSwigPublic(void *item) const {
      return Fl_Browser::item_height(item);
    }
    virtual int item_width(void *item) const;
    virtual int item_widthSwigPublic(void *item) const {
      return Fl_Browser::item_width(item);
    }
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual void item_drawSwigPublic(void *item, int X, int Y, int W, int H) const {
      Fl_Browser::item_draw(item,X,Y,W,H);
    }
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser::item_swap(a,b);
    }
    virtual void *item_at(int line) const;
    virtual void *item_atSwigPublic(int line) const {
      return Fl_Browser::item_at(line);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser::incr_height();
    }
    virtual void item_select(void *item, int val);
    virtual void item_selectSwigPublic(void *item, int val) {
      Fl_Browser::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Browser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_File_Browser : public Fl_File_Browser, public Swig::Director {

public:
    SwigDirector_Fl_File_Browser(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_File_Browser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_firstSwigPublic() const {
      return Fl_Browser::item_first();
    }
    virtual void *item_next(void *item) const;
    virtual void *item_nextSwigPublic(void *item) const {
      return Fl_Browser::item_next(item);
    }
    virtual void *item_prev(void *item) const;
    virtual void *item_prevSwigPublic(void *item) const {
      return Fl_Browser::item_prev(item);
    }
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_heightSwigPublic(void *item) const {
      return Fl_Browser::item_height(item);
    }
    virtual int item_width(void *item) const;
    virtual int item_widthSwigPublic(void *item) const {
      return Fl_Browser::item_width(item);
    }
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual void item_drawSwigPublic(void *item, int X, int Y, int W, int H) const {
      Fl_Browser::item_draw(item,X,Y,W,H);
    }
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser::item_swap(a,b);
    }
    virtual void *item_at(int line) const;
    virtual void *item_atSwigPublic(int line) const {
      return Fl_Browser::item_at(line);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser::incr_height();
    }
    virtual void item_select(void *item, int val);
    virtual void item_selectSwigPublic(void *item, int val) {
      Fl_Browser::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_File_Browser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_Adjuster : public Fl_Adjuster, public Swig::Director {

public:
    SwigDirector_Fl_Adjuster(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Adjuster();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Adjuster::draw();
    }
    virtual int handle(int arg0);
    virtual int handleSwigPublic(int arg0) {
      return Fl_Adjuster::handle(arg0);
    }
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Adjuster doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Bitmap : public Fl_Bitmap, public Swig::Director {

public:
    SwigDirector_Fl_Bitmap(PyObject *self, uchar const *bits, int W, int H);
    virtual ~SwigDirector_Fl_Bitmap();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Bitmap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_BMP_Image : public Fl_BMP_Image, public Swig::Director {

public:
    SwigDirector_Fl_BMP_Image(PyObject *self, char const *filename);
    virtual ~SwigDirector_Fl_BMP_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_BMP_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Box : public Fl_Box, public Swig::Director {

public:
    SwigDirector_Fl_Box(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    SwigDirector_Fl_Box(PyObject *self, Fl_Boxtype b, int X, int Y, int W, int H, char const *l);
    virtual ~SwigDirector_Fl_Box();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Box::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Box doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Button : public Fl_Button, public Swig::Director {

public:
    SwigDirector_Fl_Button(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Chart : public Fl_Chart, public Swig::Director {

public:
    SwigDirector_Fl_Chart(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Chart();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Chart::draw();
    }
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Chart doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Check_Browser : public Fl_Check_Browser, public Swig::Director {

public:
    SwigDirector_Fl_Check_Browser(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Check_Browser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int arg0);
    virtual int handleSwigPublic(int arg0) {
      return Fl_Check_Browser::handle(arg0);
    }
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_next(void *item) const;
    virtual void *item_prev(void *item) const;
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser_::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_width(void *item) const;
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser_::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser_::item_swap(a,b);
    }
    virtual void *item_at(int index) const;
    virtual void *item_atSwigPublic(int index) const {
      return Fl_Browser_::item_at(index);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser_::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser_::incr_height();
    }
    virtual void item_select(void *item, int val = 1);
    virtual void item_selectSwigPublic(void *item, int val = 1) {
      Fl_Browser_::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser_::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Check_Browser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_Light_Button : public Fl_Light_Button, public Swig::Director {

public:
    SwigDirector_Fl_Light_Button(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Light_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Light_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Light_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Check_Button : public Fl_Check_Button, public Swig::Director {

public:
    SwigDirector_Fl_Check_Button(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Check_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Light_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Check_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Menu_ : public Fl_Menu_, public Swig::Director {

public:
    SwigDirector_Fl_Menu_(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Menu_();
    virtual void draw();
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Menu_ doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Choice : public Fl_Choice, public Swig::Director {

public:
    SwigDirector_Fl_Choice(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Choice();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Choice::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Choice doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Clock_Output : public Fl_Clock_Output, public Swig::Director {

public:
    SwigDirector_Fl_Clock_Output(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Clock_Output();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Clock_Output::draw();
    }
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Clock_Output doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Clock : public Fl_Clock, public Swig::Director {

public:
    SwigDirector_Fl_Clock(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    SwigDirector_Fl_Clock(PyObject *self, uchar t, int X, int Y, int W, int H, char const *L);
    virtual ~SwigDirector_Fl_Clock();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Clock_Output::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Clock doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Value_Input : public Fl_Value_Input, public Swig::Director {

public:
    SwigDirector_Fl_Value_Input(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Value_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Value_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Value_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Flcc_HueBox : public Flcc_HueBox, public Swig::Director {

public:
    SwigDirector_Flcc_HueBox(PyObject *self, int X, int Y, int W, int H);
    virtual ~SwigDirector_Flcc_HueBox();
    virtual void draw();
    virtual void drawSwigPublic() {
      Flcc_HueBox::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Flcc_HueBox doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Flcc_ValueBox : public Flcc_ValueBox, public Swig::Director {

public:
    SwigDirector_Flcc_ValueBox(PyObject *self, int X, int Y, int W, int H);
    virtual ~SwigDirector_Flcc_ValueBox();
    virtual void draw();
    virtual void drawSwigPublic() {
      Flcc_ValueBox::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Flcc_ValueBox doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Flcc_Value_Input : public Flcc_Value_Input, public Swig::Director {

public:
    SwigDirector_Flcc_Value_Input(PyObject *self, int X, int Y, int W, int H);
    virtual ~SwigDirector_Flcc_Value_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Value_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *arg0);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Flcc_Value_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Color_Chooser : public Fl_Color_Chooser, public Swig::Director {

public:
    SwigDirector_Fl_Color_Chooser(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Color_Chooser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Color_Chooser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Counter : public Fl_Counter, public Swig::Director {

public:
    SwigDirector_Fl_Counter(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Counter();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Counter::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Counter doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Dial : public Fl_Dial, public Swig::Director {

public:
    SwigDirector_Fl_Dial(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Dial();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Dial::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Dial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Window : public Fl_Window, public Swig::Director {

public:
    SwigDirector_Fl_Window(PyObject *self, int w, int h, char const *title = 0);
    SwigDirector_Fl_Window(PyObject *self, int x, int y, int w, int h, char const *title = 0);
    virtual ~SwigDirector_Fl_Window();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Window::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int X, int Y, int W, int H);
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void flush();
    virtual void flushSwigPublic() {
      Fl_Window::flush();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Window doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Double_Window : public Fl_Double_Window, public Swig::Director {

public:
    SwigDirector_Fl_Double_Window(PyObject *self, int W, int H, char const *l = 0);
    SwigDirector_Fl_Double_Window(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Double_Window();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Window::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void flush();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Double_Window doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Input_ : public Fl_Input_, public Swig::Director {

public:
    SwigDirector_Fl_Input_(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Input_();
    virtual void draw();
    virtual int handle(int event);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Input_ doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Input : public Fl_Input, public Swig::Director {

public:
    SwigDirector_Fl_Input(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_File_Input : public Fl_File_Input, public Swig::Director {

public:
    SwigDirector_Fl_File_Input(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_File_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_File_Input::draw();
    }
    virtual int handle(int event);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_File_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Fill_Dial : public Fl_Fill_Dial, public Swig::Director {

public:
    SwigDirector_Fl_Fill_Dial(PyObject *self, int X, int Y, int W, int H, char const *L);
    virtual ~SwigDirector_Fl_Fill_Dial();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Dial::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Fill_Dial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Slider : public Fl_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Slider(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    SwigDirector_Fl_Slider(PyObject *self, uchar t, int X, int Y, int W, int H, char const *L);
    virtual ~SwigDirector_Fl_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Fill_Slider : public Fl_Fill_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Fill_Slider(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Fill_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Fill_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Float_Input : public Fl_Float_Input, public Swig::Director {

public:
    SwigDirector_Fl_Float_Input(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Float_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Float_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_FormsBitmap : public Fl_FormsBitmap, public Swig::Director {

public:
    SwigDirector_Fl_FormsBitmap(PyObject *self, Fl_Boxtype arg0, int arg1, int arg2, int arg3, int arg4, char const *arg5 = 0);
    virtual ~SwigDirector_Fl_FormsBitmap();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_FormsBitmap::draw();
    }
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_FormsBitmap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_FormsPixmap : public Fl_FormsPixmap, public Swig::Director {

public:
    SwigDirector_Fl_FormsPixmap(PyObject *self, Fl_Boxtype t, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_FormsPixmap();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_FormsPixmap::draw();
    }
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_FormsPixmap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Free : public Fl_Free, public Swig::Director {

public:
    SwigDirector_Fl_Free(PyObject *self, uchar t, int X, int Y, int W, int H, char const *L, FL_HANDLEPTR hdl);
    virtual ~SwigDirector_Fl_Free();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Free::draw();
    }
    virtual int handle(int e);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Free doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Pixmap : public Fl_Pixmap, public Swig::Director {

public:
    SwigDirector_Fl_Pixmap(PyObject *self, char const *const *D);
    virtual ~SwigDirector_Fl_Pixmap();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Pixmap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_GIF_Image : public Fl_GIF_Image, public Swig::Director {

public:
    SwigDirector_Fl_GIF_Image(PyObject *self, char const *filename);
    virtual ~SwigDirector_Fl_GIF_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_GIF_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Gl_Window : public Fl_Gl_Window, public Swig::Director {

public:
    SwigDirector_Fl_Gl_Window(PyObject *self, int W, int H, char const *l = 0);
    SwigDirector_Fl_Gl_Window(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Gl_Window();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Gl_Window::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void flush();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Gl_Window doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Help_View : public Fl_Help_View, public Swig::Director {

public:
    SwigDirector_Fl_Help_View(PyObject *self, int xx, int yy, int ww, int hh, char const *l = 0);
    virtual ~SwigDirector_Fl_Help_View();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Help_View doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Hold_Browser : public Fl_Hold_Browser, public Swig::Director {

public:
    SwigDirector_Fl_Hold_Browser(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Hold_Browser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_firstSwigPublic() const {
      return Fl_Browser::item_first();
    }
    virtual void *item_next(void *item) const;
    virtual void *item_nextSwigPublic(void *item) const {
      return Fl_Browser::item_next(item);
    }
    virtual void *item_prev(void *item) const;
    virtual void *item_prevSwigPublic(void *item) const {
      return Fl_Browser::item_prev(item);
    }
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_heightSwigPublic(void *item) const {
      return Fl_Browser::item_height(item);
    }
    virtual int item_width(void *item) const;
    virtual int item_widthSwigPublic(void *item) const {
      return Fl_Browser::item_width(item);
    }
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual void item_drawSwigPublic(void *item, int X, int Y, int W, int H) const {
      Fl_Browser::item_draw(item,X,Y,W,H);
    }
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser::item_swap(a,b);
    }
    virtual void *item_at(int line) const;
    virtual void *item_atSwigPublic(int line) const {
      return Fl_Browser::item_at(line);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser::incr_height();
    }
    virtual void item_select(void *item, int val);
    virtual void item_selectSwigPublic(void *item, int val) {
      Fl_Browser::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Hold_Browser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_Hor_Fill_Slider : public Fl_Hor_Fill_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Hor_Fill_Slider(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Hor_Fill_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Hor_Fill_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Hor_Nice_Slider : public Fl_Hor_Nice_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Hor_Nice_Slider(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Hor_Nice_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Hor_Nice_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Hor_Slider : public Fl_Hor_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Hor_Slider(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Hor_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Hor_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Value_Slider : public Fl_Value_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Value_Slider(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Value_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Value_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Value_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Hor_Value_Slider : public Fl_Hor_Value_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Hor_Value_Slider(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Hor_Value_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Value_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Hor_Value_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Int_Input : public Fl_Int_Input, public Swig::Director {

public:
    SwigDirector_Fl_Int_Input(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Int_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Int_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Input_Choice : public Fl_Input_Choice, public Swig::Director {

public:
    SwigDirector_Fl_Input_Choice(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Input_Choice();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Input_Choice doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_JPEG_Image : public Fl_JPEG_Image, public Swig::Director {

public:
    SwigDirector_Fl_JPEG_Image(PyObject *self, char const *filename);
    SwigDirector_Fl_JPEG_Image(PyObject *self, char const *name, unsigned char const *data);
    virtual ~SwigDirector_Fl_JPEG_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_JPEG_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Line_Dial : public Fl_Line_Dial, public Swig::Director {

public:
    SwigDirector_Fl_Line_Dial(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Line_Dial();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Dial::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Line_Dial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Menu_Bar : public Fl_Menu_Bar, public Swig::Director {

public:
    SwigDirector_Fl_Menu_Bar(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Menu_Bar();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Menu_Bar::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Menu_Bar doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Menu_Button : public Fl_Menu_Button, public Swig::Director {

public:
    SwigDirector_Fl_Menu_Button(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Menu_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Menu_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Menu_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Single_Window : public Fl_Single_Window, public Swig::Director {

public:
    SwigDirector_Fl_Single_Window(PyObject *self, int W, int H, char const *l = 0);
    SwigDirector_Fl_Single_Window(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Single_Window();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Window::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int X, int Y, int W, int H);
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void flush();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Single_Window doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Menu_Window : public Fl_Menu_Window, public Swig::Director {

public:
    SwigDirector_Fl_Menu_Window(PyObject *self, int W, int H, char const *l = 0);
    SwigDirector_Fl_Menu_Window(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Menu_Window();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Window::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int X, int Y, int W, int H);
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void flush();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Menu_Window doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Multiline_Input : public Fl_Multiline_Input, public Swig::Director {

public:
    SwigDirector_Fl_Multiline_Input(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Multiline_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Multiline_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Output : public Fl_Output, public Swig::Director {

public:
    SwigDirector_Fl_Output(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Output();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Output doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Multiline_Output : public Fl_Multiline_Output, public Swig::Director {

public:
    SwigDirector_Fl_Multiline_Output(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Multiline_Output();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Multiline_Output doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Multi_Browser : public Fl_Multi_Browser, public Swig::Director {

public:
    SwigDirector_Fl_Multi_Browser(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Multi_Browser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_firstSwigPublic() const {
      return Fl_Browser::item_first();
    }
    virtual void *item_next(void *item) const;
    virtual void *item_nextSwigPublic(void *item) const {
      return Fl_Browser::item_next(item);
    }
    virtual void *item_prev(void *item) const;
    virtual void *item_prevSwigPublic(void *item) const {
      return Fl_Browser::item_prev(item);
    }
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_heightSwigPublic(void *item) const {
      return Fl_Browser::item_height(item);
    }
    virtual int item_width(void *item) const;
    virtual int item_widthSwigPublic(void *item) const {
      return Fl_Browser::item_width(item);
    }
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual void item_drawSwigPublic(void *item, int X, int Y, int W, int H) const {
      Fl_Browser::item_draw(item,X,Y,W,H);
    }
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser::item_swap(a,b);
    }
    virtual void *item_at(int line) const;
    virtual void *item_atSwigPublic(int line) const {
      return Fl_Browser::item_at(line);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser::incr_height();
    }
    virtual void item_select(void *item, int val);
    virtual void item_selectSwigPublic(void *item, int val) {
      Fl_Browser::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Multi_Browser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_Nice_Slider : public Fl_Nice_Slider, public Swig::Director {

public:
    SwigDirector_Fl_Nice_Slider(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Nice_Slider();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Slider::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Nice_Slider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Overlay_Window : public Fl_Overlay_Window, public Swig::Director {

public:
    SwigDirector_Fl_Overlay_Window(PyObject *self, int W, int H, char const *l = 0);
    SwigDirector_Fl_Overlay_Window(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Overlay_Window();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Window::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void flush();
    virtual void draw_overlay();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Overlay_Window doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Pack : public Fl_Pack, public Swig::Director {

public:
    SwigDirector_Fl_Pack(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Pack();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Pack::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Pack doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_PNG_Image : public Fl_PNG_Image, public Swig::Director {

public:
    SwigDirector_Fl_PNG_Image(PyObject *self, char const *filename);
    SwigDirector_Fl_PNG_Image(PyObject *self, char const *name_png, unsigned char const *buffer, int datasize);
    virtual ~SwigDirector_Fl_PNG_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_PNG_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_PNM_Image : public Fl_PNM_Image, public Swig::Director {

public:
    SwigDirector_Fl_PNM_Image(PyObject *self, char const *filename);
    virtual ~SwigDirector_Fl_PNM_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_PNM_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Positioner : public Fl_Positioner, public Swig::Director {

public:
    SwigDirector_Fl_Positioner(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Positioner();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Positioner::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Positioner doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Progress : public Fl_Progress, public Swig::Director {

public:
    SwigDirector_Fl_Progress(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Progress();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Progress::draw();
    }
    virtual int handle(int event);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Progress doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Radio_Button : public Fl_Radio_Button, public Swig::Director {

public:
    SwigDirector_Fl_Radio_Button(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Radio_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Radio_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Radio_Light_Button : public Fl_Radio_Light_Button, public Swig::Director {

public:
    SwigDirector_Fl_Radio_Light_Button(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Radio_Light_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Light_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Radio_Light_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Round_Button : public Fl_Round_Button, public Swig::Director {

public:
    SwigDirector_Fl_Round_Button(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Round_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Light_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Round_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Radio_Round_Button : public Fl_Radio_Round_Button, public Swig::Director {

public:
    SwigDirector_Fl_Radio_Round_Button(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Radio_Round_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Light_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Radio_Round_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Repeat_Button : public Fl_Repeat_Button, public Swig::Director {

public:
    SwigDirector_Fl_Repeat_Button(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Repeat_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Repeat_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Return_Button : public Fl_Return_Button, public Swig::Director {

public:
    SwigDirector_Fl_Return_Button(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Return_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Return_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Return_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Roller : public Fl_Roller, public Swig::Director {

public:
    SwigDirector_Fl_Roller(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Roller();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Roller::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Roller doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Round_Clock : public Fl_Round_Clock, public Swig::Director {

public:
    SwigDirector_Fl_Round_Clock(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Round_Clock();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Clock_Output::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Round_Clock doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Scroll : public Fl_Scroll, public Swig::Director {

public:
    SwigDirector_Fl_Scroll(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Scroll();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Scroll::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Scroll doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Scrollbar : public Fl_Scrollbar, public Swig::Director {

public:
    SwigDirector_Fl_Scrollbar(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Scrollbar();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Scrollbar::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Scrollbar doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Secret_Input : public Fl_Secret_Input, public Swig::Director {

public:
    SwigDirector_Fl_Secret_Input(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Secret_Input();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Input::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Secret_Input doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Select_Browser : public Fl_Select_Browser, public Swig::Director {

public:
    SwigDirector_Fl_Select_Browser(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Select_Browser();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Browser_::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void *item_first() const;
    virtual void *item_firstSwigPublic() const {
      return Fl_Browser::item_first();
    }
    virtual void *item_next(void *item) const;
    virtual void *item_nextSwigPublic(void *item) const {
      return Fl_Browser::item_next(item);
    }
    virtual void *item_prev(void *item) const;
    virtual void *item_prevSwigPublic(void *item) const {
      return Fl_Browser::item_prev(item);
    }
    virtual void *item_last() const;
    virtual void *item_lastSwigPublic() const {
      return Fl_Browser::item_last();
    }
    virtual int item_height(void *item) const;
    virtual int item_heightSwigPublic(void *item) const {
      return Fl_Browser::item_height(item);
    }
    virtual int item_width(void *item) const;
    virtual int item_widthSwigPublic(void *item) const {
      return Fl_Browser::item_width(item);
    }
    virtual int item_quick_height(void *item) const;
    virtual int item_quick_heightSwigPublic(void *item) const {
      return Fl_Browser_::item_quick_height(item);
    }
    virtual void item_draw(void *item, int X, int Y, int W, int H) const;
    virtual void item_drawSwigPublic(void *item, int X, int Y, int W, int H) const {
      Fl_Browser::item_draw(item,X,Y,W,H);
    }
    virtual char const *item_text(void *item) const;
    virtual char const *item_textSwigPublic(void *item) const {
      return Fl_Browser::item_text(item);
    }
    virtual void item_swap(void *a, void *b);
    virtual void item_swapSwigPublic(void *a, void *b) {
      Fl_Browser::item_swap(a,b);
    }
    virtual void *item_at(int line) const;
    virtual void *item_atSwigPublic(int line) const {
      return Fl_Browser::item_at(line);
    }
    virtual int full_width() const;
    virtual int full_widthSwigPublic() const {
      return Fl_Browser_::full_width();
    }
    virtual int full_height() const;
    virtual int full_heightSwigPublic() const {
      return Fl_Browser::full_height();
    }
    virtual int incr_height() const;
    virtual int incr_heightSwigPublic() const {
      return Fl_Browser::incr_height();
    }
    virtual void item_select(void *item, int val);
    virtual void item_selectSwigPublic(void *item, int val) {
      Fl_Browser::item_select(item,val);
    }
    virtual int item_selected(void *item) const;
    virtual int item_selectedSwigPublic(void *item) const {
      return Fl_Browser::item_selected(item);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Select_Browser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[24];
#endif

};


class SwigDirector_Fl_Shared_Image : public Fl_Shared_Image, public Swig::Director {

public:
    SwigDirector_Fl_Shared_Image(PyObject *self);
    SwigDirector_Fl_Shared_Image(PyObject *self, char const *n, Fl_Image *img = 0);
    virtual ~SwigDirector_Fl_Shared_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx, int cy);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Shared_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Spinner : public Fl_Spinner, public Swig::Director {

public:
    SwigDirector_Fl_Spinner(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Spinner();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Spinner doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Simple_Counter : public Fl_Simple_Counter, public Swig::Director {

public:
    SwigDirector_Fl_Simple_Counter(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Simple_Counter();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Counter::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Simple_Counter doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Tabs : public Fl_Tabs, public Swig::Director {

public:
    SwigDirector_Fl_Tabs(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Tabs();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Tabs::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Tabs doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Text_Display : public Fl_Text_Display, public Swig::Director {

public:
    SwigDirector_Fl_Text_Display(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Text_Display();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Text_Display::draw();
    }
    virtual int handle(int e);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Text_Display doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Text_Editor : public Fl_Text_Editor, public Swig::Director {

public:
    SwigDirector_Fl_Text_Editor(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Text_Editor();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Text_Display::draw();
    }
    virtual int handle(int e);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Text_Editor doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Tile : public Fl_Tile, public Swig::Director {

public:
    SwigDirector_Fl_Tile(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Tile();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int event);
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Tile doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Tiled_Image : public Fl_Tiled_Image, public Swig::Director {

public:
    SwigDirector_Fl_Tiled_Image(PyObject *self, Fl_Image *i, int W = 0, int H = 0);
    virtual ~SwigDirector_Fl_Tiled_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx, int cy);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Tiled_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Timer : public Fl_Timer, public Swig::Director {

public:
    SwigDirector_Fl_Timer(PyObject *self, uchar t, int x, int y, int w, int h, char const *l);
    virtual ~SwigDirector_Fl_Timer();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Timer::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Timer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Toggle_Button : public Fl_Toggle_Button, public Swig::Director {

public:
    SwigDirector_Fl_Toggle_Button(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Toggle_Button();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Button::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Toggle_Button doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Value_Output : public Fl_Value_Output, public Swig::Director {

public:
    SwigDirector_Fl_Value_Output(PyObject *self, int x, int y, int w, int h, char const *l = 0);
    virtual ~SwigDirector_Fl_Value_Output();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Value_Output::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual int format(char *format_string);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Value_Output doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Fl_Wizard : public Fl_Wizard, public Swig::Director {

public:
    SwigDirector_Fl_Wizard(PyObject *self, int arg0, int arg1, int arg2, int arg3, char const *arg4 = 0);
    virtual ~SwigDirector_Fl_Wizard();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Wizard doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_XBM_Image : public Fl_XBM_Image, public Swig::Director {

public:
    SwigDirector_Fl_XBM_Image(PyObject *self, char const *filename);
    virtual ~SwigDirector_Fl_XBM_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_XBM_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_XPM_Image : public Fl_XPM_Image, public Swig::Director {

public:
    SwigDirector_Fl_XPM_Image(PyObject *self, char const *filename);
    virtual ~SwigDirector_Fl_XPM_Image();
    virtual Fl_Image *copy(int W, int H);
    virtual void color_average(Fl_Color c, float i);
    virtual void desaturate();
    virtual void label(Fl_Widget *w);
    virtual void label(Fl_Menu_Item *m);
    virtual void draw(int X, int Y, int W, int H, int cx = 0, int cy = 0);
    virtual void uncache();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_XPM_Image doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_Fl_Tree : public Fl_Tree, public Swig::Director {

public:
    SwigDirector_Fl_Tree(PyObject *self, int X, int Y, int W, int H, char const *L = 0);
    virtual ~SwigDirector_Fl_Tree();
    virtual void draw();
    virtual int handle(int e);
    virtual void resize(int arg0, int arg1, int arg2, int arg3);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Tree doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Paged_Device : public Fl_Paged_Device, public Swig::Director {

public:
    SwigDirector_Fl_Paged_Device(PyObject *self);
    virtual ~SwigDirector_Fl_Paged_Device();
    virtual int start_job(int pagecount, int *frompage = NULL, int *topage = NULL);
    virtual int start_page();
    virtual int printable_rect(int *w, int *h);
    virtual void margins(int *left, int *top, int *right, int *bottom);
    virtual void origin(int x, int y);
    virtual void origin(int *x, int *y);
    virtual void scale(float scale_x, float scale_y = 0.);
    virtual void rotate(float angle);
    virtual void translate(int x, int y);
    virtual void untranslate();
    virtual void print_widget(Fl_Widget *widget, int delta_x = 0, int delta_y = 0);
    virtual void print_window_part(Fl_Window *win, int x, int y, int w, int h, int delta_x = 0, int delta_y = 0);
    virtual int end_page();
    virtual void end_job();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Paged_Device doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_Fl_Printer : public Fl_Printer, public Swig::Director {

public:
    SwigDirector_Fl_Printer(PyObject *self);
    virtual ~SwigDirector_Fl_Printer();
    virtual int start_job(int pagecount, int *frompage = NULL, int *topage = NULL);
    virtual int start_page();
    virtual int printable_rect(int *w, int *h);
    virtual void margins(int *left, int *top, int *right, int *bottom);
    virtual void origin(int x, int y);
    virtual void origin(int *x, int *y);
    virtual void scale(float scale_x, float scale_y = 0.);
    virtual void rotate(float angle);
    virtual void translate(int x, int y);
    virtual void untranslate();
    virtual void print_widget(Fl_Widget *widget, int delta_x = 0, int delta_y = 0);
    virtual void print_window_part(Fl_Window *win, int x, int y, int w, int h, int delta_x = 0, int delta_y = 0);
    virtual int end_page();
    virtual void end_job();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Printer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_ListSelect : public ListSelect, public Swig::Director {

public:
    SwigDirector_ListSelect(PyObject *self, int x, int y, int w, int h, char *topLabel = 0, char *bottomLabel = 0);
    virtual ~SwigDirector_ListSelect();
    virtual void draw();
    virtual void drawSwigPublic() {
      Fl_Group::draw();
    }
    virtual int handle(int arg0);
    virtual void resize(int x, int y, int w, int h);
    virtual void resizeSwigPublic(int x, int y, int w, int h) {
      ListSelect::resize(x,y,w,h);
    }
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ListSelect doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


class SwigDirector_Fl_Table : public Fl_Table, public Swig::Director {

public:
    SwigDirector_Fl_Table(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Table();
    virtual void draw();
    virtual int handle(int e);
    virtual int handleSwigPublic(int e) {
      return Fl_Table::handle(e);
    }
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void draw_cell(Fl_Table::TableContext context, int R = 0, int C = 0, int X = 0, int Y = 0, int W = 0, int H = 0);
    virtual void draw_cellSwigPublic(Fl_Table::TableContext context, int R = 0, int C = 0, int X = 0, int Y = 0, int W = 0, int H = 0) {
      Fl_Table::draw_cell(context,R,C,X,Y,W,H);
    }
    virtual void clear();
    virtual void rows(int val);
    virtual void cols(int val);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Table doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


class SwigDirector_Fl_Table_Row : public Fl_Table_Row, public Swig::Director {

public:
    SwigDirector_Fl_Table_Row(PyObject *self, int X, int Y, int W, int H, char const *l = 0);
    virtual ~SwigDirector_Fl_Table_Row();
    virtual void draw();
    virtual int handle(int event);
    virtual int handleSwigPublic(int event) {
      return Fl_Table_Row::handle(event);
    }
    virtual void resize(int X, int Y, int W, int H);
    virtual void show();
    virtual void hide();
    virtual Fl_Group *as_group();
    virtual Fl_Window *as_window();
    virtual Fl_Gl_Window *as_gl_window();
    virtual void draw_cell(Fl_Table::TableContext context, int R = 0, int C = 0, int X = 0, int Y = 0, int W = 0, int H = 0);
    virtual void draw_cellSwigPublic(Fl_Table::TableContext context, int R = 0, int C = 0, int X = 0, int Y = 0, int W = 0, int H = 0) {
      Fl_Table::draw_cell(context,R,C,X,Y,W,H);
    }
    virtual void clear();
    virtual void rows(int val);
    virtual void cols(int val);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Fl_Table_Row doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


#endif
