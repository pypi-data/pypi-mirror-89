# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_pyaruco')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_pyaruco')
    _pyaruco = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyaruco', [dirname(__file__)])
        except ImportError:
            import _pyaruco
            return _pyaruco
        try:
            _mod = imp.load_module('_pyaruco', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _pyaruco = swig_import_helper()
    del swig_import_helper
else:
    import _pyaruco
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


import collections
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaruco.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _pyaruco.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _pyaruco.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _pyaruco.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _pyaruco.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _pyaruco.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _pyaruco.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _pyaruco.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _pyaruco.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _pyaruco.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _pyaruco.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _pyaruco.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _pyaruco.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _pyaruco.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _pyaruco.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _pyaruco.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _pyaruco.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _pyaruco.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class VectorInt(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyaruco.VectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyaruco.VectorInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyaruco.VectorInt___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _pyaruco.VectorInt___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _pyaruco.VectorInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyaruco.VectorInt___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _pyaruco.VectorInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyaruco.VectorInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _pyaruco.VectorInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyaruco.VectorInt___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _pyaruco.VectorInt_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _pyaruco.VectorInt_append(self, x)

    def empty(self) -> "bool":
        return _pyaruco.VectorInt_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _pyaruco.VectorInt_size(self)

    def swap(self, v: 'VectorInt') -> "void":
        return _pyaruco.VectorInt_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _pyaruco.VectorInt_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _pyaruco.VectorInt_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _pyaruco.VectorInt_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _pyaruco.VectorInt_rend(self)

    def clear(self) -> "void":
        return _pyaruco.VectorInt_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _pyaruco.VectorInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyaruco.VectorInt_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _pyaruco.VectorInt_erase(self, *args)

    def __init__(self, *args):
        this = _pyaruco.new_VectorInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _pyaruco.VectorInt_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _pyaruco.VectorInt_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _pyaruco.VectorInt_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _pyaruco.VectorInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyaruco.VectorInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyaruco.VectorInt_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _pyaruco.VectorInt_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _pyaruco.VectorInt_capacity(self)
    __swig_destroy__ = _pyaruco.delete_VectorInt
    __del__ = lambda self: None
VectorInt_swigregister = _pyaruco.VectorInt_swigregister
VectorInt_swigregister(VectorInt)

class Point2fVec(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point2fVec, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Point2fVec, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyaruco.Point2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyaruco.Point2fVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyaruco.Point2fVec___bool__(self)

    def __len__(self) -> "std::vector< cv::Point2f >::size_type":
        return _pyaruco.Point2fVec___len__(self)

    def __getslice__(self, i: 'std::vector< cv::Point2f >::difference_type', j: 'std::vector< cv::Point2f >::difference_type') -> "std::vector< cv::Point2f,std::allocator< cv::Point2f > > *":
        return _pyaruco.Point2fVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyaruco.Point2fVec___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< cv::Point2f >::difference_type', j: 'std::vector< cv::Point2f >::difference_type') -> "void":
        return _pyaruco.Point2fVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyaruco.Point2fVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< cv::Point2f >::value_type const &":
        return _pyaruco.Point2fVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyaruco.Point2fVec___setitem__(self, *args)

    def pop(self) -> "std::vector< cv::Point2f >::value_type":
        return _pyaruco.Point2fVec_pop(self)

    def append(self, x: 'std::vector< cv::Point2f >::value_type const &') -> "void":
        return _pyaruco.Point2fVec_append(self, x)

    def empty(self) -> "bool":
        return _pyaruco.Point2fVec_empty(self)

    def size(self) -> "std::vector< cv::Point2f >::size_type":
        return _pyaruco.Point2fVec_size(self)

    def swap(self, v: 'Point2fVec') -> "void":
        return _pyaruco.Point2fVec_swap(self, v)

    def begin(self) -> "std::vector< cv::Point2f >::iterator":
        return _pyaruco.Point2fVec_begin(self)

    def end(self) -> "std::vector< cv::Point2f >::iterator":
        return _pyaruco.Point2fVec_end(self)

    def rbegin(self) -> "std::vector< cv::Point2f >::reverse_iterator":
        return _pyaruco.Point2fVec_rbegin(self)

    def rend(self) -> "std::vector< cv::Point2f >::reverse_iterator":
        return _pyaruco.Point2fVec_rend(self)

    def clear(self) -> "void":
        return _pyaruco.Point2fVec_clear(self)

    def get_allocator(self) -> "std::vector< cv::Point2f >::allocator_type":
        return _pyaruco.Point2fVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyaruco.Point2fVec_pop_back(self)

    def erase(self, *args) -> "std::vector< cv::Point2f >::iterator":
        return _pyaruco.Point2fVec_erase(self, *args)

    def __init__(self, *args):
        this = _pyaruco.new_Point2fVec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< cv::Point2f >::value_type const &') -> "void":
        return _pyaruco.Point2fVec_push_back(self, x)

    def front(self) -> "std::vector< cv::Point2f >::value_type const &":
        return _pyaruco.Point2fVec_front(self)

    def back(self) -> "std::vector< cv::Point2f >::value_type const &":
        return _pyaruco.Point2fVec_back(self)

    def assign(self, n: 'std::vector< cv::Point2f >::size_type', x: 'std::vector< cv::Point2f >::value_type const &') -> "void":
        return _pyaruco.Point2fVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyaruco.Point2fVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyaruco.Point2fVec_insert(self, *args)

    def reserve(self, n: 'std::vector< cv::Point2f >::size_type') -> "void":
        return _pyaruco.Point2fVec_reserve(self, n)

    def capacity(self) -> "std::vector< cv::Point2f >::size_type":
        return _pyaruco.Point2fVec_capacity(self)
    __swig_destroy__ = _pyaruco.delete_Point2fVec
    __del__ = lambda self: None
Point2fVec_swigregister = _pyaruco.Point2fVec_swigregister
Point2fVec_swigregister(Point2fVec)

class Point3fVec(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point3fVec, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Point3fVec, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyaruco.Point3fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyaruco.Point3fVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyaruco.Point3fVec___bool__(self)

    def __len__(self) -> "std::vector< cv::Point3f >::size_type":
        return _pyaruco.Point3fVec___len__(self)

    def __getslice__(self, i: 'std::vector< cv::Point3f >::difference_type', j: 'std::vector< cv::Point3f >::difference_type') -> "std::vector< cv::Point3f,std::allocator< cv::Point3f > > *":
        return _pyaruco.Point3fVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyaruco.Point3fVec___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< cv::Point3f >::difference_type', j: 'std::vector< cv::Point3f >::difference_type') -> "void":
        return _pyaruco.Point3fVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyaruco.Point3fVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< cv::Point3f >::value_type const &":
        return _pyaruco.Point3fVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyaruco.Point3fVec___setitem__(self, *args)

    def pop(self) -> "std::vector< cv::Point3f >::value_type":
        return _pyaruco.Point3fVec_pop(self)

    def append(self, x: 'std::vector< cv::Point3f >::value_type const &') -> "void":
        return _pyaruco.Point3fVec_append(self, x)

    def empty(self) -> "bool":
        return _pyaruco.Point3fVec_empty(self)

    def size(self) -> "std::vector< cv::Point3f >::size_type":
        return _pyaruco.Point3fVec_size(self)

    def swap(self, v: 'Point3fVec') -> "void":
        return _pyaruco.Point3fVec_swap(self, v)

    def begin(self) -> "std::vector< cv::Point3f >::iterator":
        return _pyaruco.Point3fVec_begin(self)

    def end(self) -> "std::vector< cv::Point3f >::iterator":
        return _pyaruco.Point3fVec_end(self)

    def rbegin(self) -> "std::vector< cv::Point3f >::reverse_iterator":
        return _pyaruco.Point3fVec_rbegin(self)

    def rend(self) -> "std::vector< cv::Point3f >::reverse_iterator":
        return _pyaruco.Point3fVec_rend(self)

    def clear(self) -> "void":
        return _pyaruco.Point3fVec_clear(self)

    def get_allocator(self) -> "std::vector< cv::Point3f >::allocator_type":
        return _pyaruco.Point3fVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyaruco.Point3fVec_pop_back(self)

    def erase(self, *args) -> "std::vector< cv::Point3f >::iterator":
        return _pyaruco.Point3fVec_erase(self, *args)

    def __init__(self, *args):
        this = _pyaruco.new_Point3fVec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< cv::Point3f >::value_type const &') -> "void":
        return _pyaruco.Point3fVec_push_back(self, x)

    def front(self) -> "std::vector< cv::Point3f >::value_type const &":
        return _pyaruco.Point3fVec_front(self)

    def back(self) -> "std::vector< cv::Point3f >::value_type const &":
        return _pyaruco.Point3fVec_back(self)

    def assign(self, n: 'std::vector< cv::Point3f >::size_type', x: 'std::vector< cv::Point3f >::value_type const &') -> "void":
        return _pyaruco.Point3fVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyaruco.Point3fVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyaruco.Point3fVec_insert(self, *args)

    def reserve(self, n: 'std::vector< cv::Point3f >::size_type') -> "void":
        return _pyaruco.Point3fVec_reserve(self, n)

    def capacity(self) -> "std::vector< cv::Point3f >::size_type":
        return _pyaruco.Point3fVec_capacity(self)
    __swig_destroy__ = _pyaruco.delete_Point3fVec
    __del__ = lambda self: None
Point3fVec_swigregister = _pyaruco.Point3fVec_swigregister
Point3fVec_swigregister(Point3fVec)

class MarkerPoint3fVecVec(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerPoint3fVecVec, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerPoint3fVecVec, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyaruco.MarkerPoint3fVecVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyaruco.MarkerPoint3fVecVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyaruco.MarkerPoint3fVecVec___bool__(self)

    def __len__(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type":
        return _pyaruco.MarkerPoint3fVecVec___len__(self)

    def __getslice__(self, i: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type', j: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type') -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > > *":
        return _pyaruco.MarkerPoint3fVecVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyaruco.MarkerPoint3fVecVec___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type', j: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type') -> "void":
        return _pyaruco.MarkerPoint3fVecVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyaruco.MarkerPoint3fVecVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type const &":
        return _pyaruco.MarkerPoint3fVecVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyaruco.MarkerPoint3fVecVec___setitem__(self, *args)

    def pop(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type":
        return _pyaruco.MarkerPoint3fVecVec_pop(self)

    def append(self, x: 'Marker') -> "void":
        return _pyaruco.MarkerPoint3fVecVec_append(self, x)

    def empty(self) -> "bool":
        return _pyaruco.MarkerPoint3fVecVec_empty(self)

    def size(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type":
        return _pyaruco.MarkerPoint3fVecVec_size(self)

    def swap(self, v: 'MarkerPoint3fVecVec') -> "void":
        return _pyaruco.MarkerPoint3fVecVec_swap(self, v)

    def begin(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::iterator":
        return _pyaruco.MarkerPoint3fVecVec_begin(self)

    def end(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::iterator":
        return _pyaruco.MarkerPoint3fVecVec_end(self)

    def rbegin(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::reverse_iterator":
        return _pyaruco.MarkerPoint3fVecVec_rbegin(self)

    def rend(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::reverse_iterator":
        return _pyaruco.MarkerPoint3fVecVec_rend(self)

    def clear(self) -> "void":
        return _pyaruco.MarkerPoint3fVecVec_clear(self)

    def get_allocator(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::allocator_type":
        return _pyaruco.MarkerPoint3fVecVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyaruco.MarkerPoint3fVecVec_pop_back(self)

    def erase(self, *args) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::iterator":
        return _pyaruco.MarkerPoint3fVecVec_erase(self, *args)

    def __init__(self, *args):
        this = _pyaruco.new_MarkerPoint3fVecVec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'Marker') -> "void":
        return _pyaruco.MarkerPoint3fVecVec_push_back(self, x)

    def front(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type const &":
        return _pyaruco.MarkerPoint3fVecVec_front(self)

    def back(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type const &":
        return _pyaruco.MarkerPoint3fVecVec_back(self)

    def assign(self, n: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type', x: 'Marker') -> "void":
        return _pyaruco.MarkerPoint3fVecVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyaruco.MarkerPoint3fVecVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyaruco.MarkerPoint3fVecVec_insert(self, *args)

    def reserve(self, n: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type') -> "void":
        return _pyaruco.MarkerPoint3fVecVec_reserve(self, n)

    def capacity(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type":
        return _pyaruco.MarkerPoint3fVecVec_capacity(self)
    __swig_destroy__ = _pyaruco.delete_MarkerPoint3fVecVec
    __del__ = lambda self: None
MarkerPoint3fVecVec_swigregister = _pyaruco.MarkerPoint3fVecVec_swigregister
MarkerPoint3fVecVec_swigregister(MarkerPoint3fVecVec)

class VectorMarker3DInfo(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorMarker3DInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorMarker3DInfo, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyaruco.VectorMarker3DInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyaruco.VectorMarker3DInfo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyaruco.VectorMarker3DInfo___bool__(self)

    def __len__(self) -> "std::vector< aruco::Marker3DInfo >::size_type":
        return _pyaruco.VectorMarker3DInfo___len__(self)

    def __getslice__(self, i: 'std::vector< aruco::Marker3DInfo >::difference_type', j: 'std::vector< aruco::Marker3DInfo >::difference_type') -> "std::vector< aruco::Marker3DInfo,std::allocator< aruco::Marker3DInfo > > *":
        return _pyaruco.VectorMarker3DInfo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyaruco.VectorMarker3DInfo___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< aruco::Marker3DInfo >::difference_type', j: 'std::vector< aruco::Marker3DInfo >::difference_type') -> "void":
        return _pyaruco.VectorMarker3DInfo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyaruco.VectorMarker3DInfo___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< aruco::Marker3DInfo >::value_type const &":
        return _pyaruco.VectorMarker3DInfo___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyaruco.VectorMarker3DInfo___setitem__(self, *args)

    def pop(self) -> "std::vector< aruco::Marker3DInfo >::value_type":
        return _pyaruco.VectorMarker3DInfo_pop(self)

    def append(self, x: 'Marker3DInfo') -> "void":
        return _pyaruco.VectorMarker3DInfo_append(self, x)

    def empty(self) -> "bool":
        return _pyaruco.VectorMarker3DInfo_empty(self)

    def size(self) -> "std::vector< aruco::Marker3DInfo >::size_type":
        return _pyaruco.VectorMarker3DInfo_size(self)

    def swap(self, v: 'VectorMarker3DInfo') -> "void":
        return _pyaruco.VectorMarker3DInfo_swap(self, v)

    def begin(self) -> "std::vector< aruco::Marker3DInfo >::iterator":
        return _pyaruco.VectorMarker3DInfo_begin(self)

    def end(self) -> "std::vector< aruco::Marker3DInfo >::iterator":
        return _pyaruco.VectorMarker3DInfo_end(self)

    def rbegin(self) -> "std::vector< aruco::Marker3DInfo >::reverse_iterator":
        return _pyaruco.VectorMarker3DInfo_rbegin(self)

    def rend(self) -> "std::vector< aruco::Marker3DInfo >::reverse_iterator":
        return _pyaruco.VectorMarker3DInfo_rend(self)

    def clear(self) -> "void":
        return _pyaruco.VectorMarker3DInfo_clear(self)

    def get_allocator(self) -> "std::vector< aruco::Marker3DInfo >::allocator_type":
        return _pyaruco.VectorMarker3DInfo_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyaruco.VectorMarker3DInfo_pop_back(self)

    def erase(self, *args) -> "std::vector< aruco::Marker3DInfo >::iterator":
        return _pyaruco.VectorMarker3DInfo_erase(self, *args)

    def __init__(self, *args):
        this = _pyaruco.new_VectorMarker3DInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'Marker3DInfo') -> "void":
        return _pyaruco.VectorMarker3DInfo_push_back(self, x)

    def front(self) -> "std::vector< aruco::Marker3DInfo >::value_type const &":
        return _pyaruco.VectorMarker3DInfo_front(self)

    def back(self) -> "std::vector< aruco::Marker3DInfo >::value_type const &":
        return _pyaruco.VectorMarker3DInfo_back(self)

    def assign(self, n: 'std::vector< aruco::Marker3DInfo >::size_type', x: 'Marker3DInfo') -> "void":
        return _pyaruco.VectorMarker3DInfo_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyaruco.VectorMarker3DInfo_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyaruco.VectorMarker3DInfo_insert(self, *args)

    def reserve(self, n: 'std::vector< aruco::Marker3DInfo >::size_type') -> "void":
        return _pyaruco.VectorMarker3DInfo_reserve(self, n)

    def capacity(self) -> "std::vector< aruco::Marker3DInfo >::size_type":
        return _pyaruco.VectorMarker3DInfo_capacity(self)
    __swig_destroy__ = _pyaruco.delete_VectorMarker3DInfo
    __del__ = lambda self: None
VectorMarker3DInfo_swigregister = _pyaruco.VectorMarker3DInfo_swigregister
VectorMarker3DInfo_swigregister(VectorMarker3DInfo)

ARUCO_VERSION_MAJOR = _pyaruco.ARUCO_VERSION_MAJOR
ARUCO_VERSION_MINOR = _pyaruco.ARUCO_VERSION_MINOR
class CameraParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CameraParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["CameraMatrix"] = _pyaruco.CameraParameters_CameraMatrix_set
    __swig_getmethods__["CameraMatrix"] = _pyaruco.CameraParameters_CameraMatrix_get
    if _newclass:
        CameraMatrix = _swig_property(_pyaruco.CameraParameters_CameraMatrix_get, _pyaruco.CameraParameters_CameraMatrix_set)
    __swig_setmethods__["Distorsion"] = _pyaruco.CameraParameters_Distorsion_set
    __swig_getmethods__["Distorsion"] = _pyaruco.CameraParameters_Distorsion_get
    if _newclass:
        Distorsion = _swig_property(_pyaruco.CameraParameters_Distorsion_get, _pyaruco.CameraParameters_Distorsion_set)
    __swig_setmethods__["CamSize"] = _pyaruco.CameraParameters_CamSize_set
    __swig_getmethods__["CamSize"] = _pyaruco.CameraParameters_CamSize_get
    if _newclass:
        CamSize = _swig_property(_pyaruco.CameraParameters_CamSize_get, _pyaruco.CameraParameters_CamSize_set)

    def setParams(self, cameraMatrix: 'cv::Mat', distorsionCoeff: 'cv::Mat', size: 'cv::Size') -> "void":
        return _pyaruco.CameraParameters_setParams(self, cameraMatrix, distorsionCoeff, size)

    def __init__(self, *args):
        this = _pyaruco.new_CameraParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isValid(self) -> "bool":
        return _pyaruco.CameraParameters_isValid(self)

    def saveToFile(self, path: 'std::string', inXML: 'bool'=True) -> "void":
        return _pyaruco.CameraParameters_saveToFile(self, path, inXML)

    def readFromXMLFile(self, filePath: 'std::string') -> "void":
        return _pyaruco.CameraParameters_readFromXMLFile(self, filePath)

    def resize(self, size: 'cv::Size') -> "void":
        return _pyaruco.CameraParameters_resize(self, size)
    if _newclass:
        getCameraLocation = staticmethod(_pyaruco.CameraParameters_getCameraLocation)
    else:
        getCameraLocation = _pyaruco.CameraParameters_getCameraLocation

    def glGetProjectionMatrix(self, orgImgSize: 'cv::Size', size: 'cv::Size', proj_matrix: 'double [16]', gnear: 'double', gfar: 'double', invert: 'bool'=False) -> "void":
        return _pyaruco.CameraParameters_glGetProjectionMatrix(self, orgImgSize, size, proj_matrix, gnear, gfar, invert)

    def OgreGetProjectionMatrix(self, orgImgSize: 'cv::Size', size: 'cv::Size', proj_matrix: 'double [16]', gnear: 'double', gfar: 'double', invert: 'bool'=False) -> "void":
        return _pyaruco.CameraParameters_OgreGetProjectionMatrix(self, orgImgSize, size, proj_matrix, gnear, gfar, invert)
    if _newclass:
        getRTMatrix = staticmethod(_pyaruco.CameraParameters_getRTMatrix)
    else:
        getRTMatrix = _pyaruco.CameraParameters_getRTMatrix

    def clear(self) -> "void":
        return _pyaruco.CameraParameters_clear(self)
    __swig_destroy__ = _pyaruco.delete_CameraParameters
    __del__ = lambda self: None
CameraParameters_swigregister = _pyaruco.CameraParameters_swigregister
CameraParameters_swigregister(CameraParameters)

def CameraParameters_getCameraLocation(Rvec: 'cv::Mat const &', Tvec: 'cv::Mat const &') -> "cv::Mat const &, cv::Mat const &":
    return _pyaruco.CameraParameters_getCameraLocation(Rvec, Tvec)
CameraParameters_getCameraLocation = _pyaruco.CameraParameters_getCameraLocation

def CameraParameters_getRTMatrix(R_: 'cv::Mat const &', T_: 'cv::Mat const &', forceType: 'int') -> "cv::Mat const &, cv::Mat const &":
    return _pyaruco.CameraParameters_getRTMatrix(R_, T_, forceType)
CameraParameters_getRTMatrix = _pyaruco.CameraParameters_getRTMatrix

class CvDrawingUtils(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CvDrawingUtils, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CvDrawingUtils, name)
    __repr__ = _swig_repr
    if _newclass:
        draw3dAxis = staticmethod(_pyaruco.CvDrawingUtils_draw3dAxis)
    else:
        draw3dAxis = _pyaruco.CvDrawingUtils_draw3dAxis
    if _newclass:
        draw3dCube = staticmethod(_pyaruco.CvDrawingUtils_draw3dCube)
    else:
        draw3dCube = _pyaruco.CvDrawingUtils_draw3dCube

    def __init__(self):
        this = _pyaruco.new_CvDrawingUtils()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_CvDrawingUtils
    __del__ = lambda self: None
CvDrawingUtils_swigregister = _pyaruco.CvDrawingUtils_swigregister
CvDrawingUtils_swigregister(CvDrawingUtils)

def CvDrawingUtils_draw3dAxis(*args) -> "cv::Mat &":
    return _pyaruco.CvDrawingUtils_draw3dAxis(*args)
CvDrawingUtils_draw3dAxis = _pyaruco.CvDrawingUtils_draw3dAxis

def CvDrawingUtils_draw3dCube(Image: 'cv::Mat &', m: 'Marker &', CP: 'CameraParameters', lineSize: 'int'=1, setYperpendicular: 'bool'=False) -> "cv::Mat &":
    return _pyaruco.CvDrawingUtils_draw3dCube(Image, m, CP, lineSize, setYperpendicular)
CvDrawingUtils_draw3dCube = _pyaruco.CvDrawingUtils_draw3dCube

class Debug(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Debug, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Debug, name)
    __repr__ = _swig_repr
    if _newclass:
        init = staticmethod(_pyaruco.Debug_init)
    else:
        init = _pyaruco.Debug_init
    if _newclass:
        setLevel = staticmethod(_pyaruco.Debug_setLevel)
    else:
        setLevel = _pyaruco.Debug_setLevel
    if _newclass:
        getLevel = staticmethod(_pyaruco.Debug_getLevel)
    else:
        getLevel = _pyaruco.Debug_getLevel
    if _newclass:
        addString = staticmethod(_pyaruco.Debug_addString)
    else:
        addString = _pyaruco.Debug_addString
    if _newclass:
        getString = staticmethod(_pyaruco.Debug_getString)
    else:
        getString = _pyaruco.Debug_getString
    if _newclass:
        getFileName = staticmethod(_pyaruco.Debug_getFileName)
    else:
        getFileName = _pyaruco.Debug_getFileName

    def __init__(self):
        this = _pyaruco.new_Debug()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_Debug
    __del__ = lambda self: None
Debug_swigregister = _pyaruco.Debug_swigregister
Debug_swigregister(Debug)

def Debug_init() -> "void":
    return _pyaruco.Debug_init()
Debug_init = _pyaruco.Debug_init

def Debug_setLevel(l: 'int') -> "void":
    return _pyaruco.Debug_setLevel(l)
Debug_setLevel = _pyaruco.Debug_setLevel

def Debug_getLevel() -> "int":
    return _pyaruco.Debug_getLevel()
Debug_getLevel = _pyaruco.Debug_getLevel

def Debug_addString(label: 'std::string &', data: 'std::string &') -> "void":
    return _pyaruco.Debug_addString(label, data)
Debug_addString = _pyaruco.Debug_addString

def Debug_getString(str: 'std::string &') -> "std::string":
    return _pyaruco.Debug_getString(str)
Debug_getString = _pyaruco.Debug_getString

def Debug_getFileName(filepath: 'std::string') -> "std::string":
    return _pyaruco.Debug_getFileName(filepath)
Debug_getFileName = _pyaruco.Debug_getFileName

class Dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionary, name)
    __repr__ = _swig_repr
    ALL_DICTS = _pyaruco.Dictionary_ALL_DICTS
    ARUCO_MIP_36h12 = _pyaruco.Dictionary_ARUCO_MIP_36h12
    ARUCO = _pyaruco.Dictionary_ARUCO
    ARUCO_MIP_25h7 = _pyaruco.Dictionary_ARUCO_MIP_25h7
    ARUCO_MIP_16h3 = _pyaruco.Dictionary_ARUCO_MIP_16h3
    ARTAG = _pyaruco.Dictionary_ARTAG
    ARTOOLKITPLUS = _pyaruco.Dictionary_ARTOOLKITPLUS
    ARTOOLKITPLUSBCH = _pyaruco.Dictionary_ARTOOLKITPLUSBCH
    TAG16h5 = _pyaruco.Dictionary_TAG16h5
    TAG25h7 = _pyaruco.Dictionary_TAG25h7
    TAG25h9 = _pyaruco.Dictionary_TAG25h9
    TAG36h11 = _pyaruco.Dictionary_TAG36h11
    TAG36h10 = _pyaruco.Dictionary_TAG36h10
    CHILITAGS = _pyaruco.Dictionary_CHILITAGS
    CUSTOM = _pyaruco.Dictionary_CUSTOM

    def _is(self, code: 'uint64_t') -> "bool":
        return _pyaruco.Dictionary__is(self, code)

    def getType(self) -> "aruco::Dictionary::DICT_TYPES":
        return _pyaruco.Dictionary_getType(self)

    def size(self) -> "uint64_t":
        return _pyaruco.Dictionary_size(self)

    def nbits(self) -> "uint32_t":
        return _pyaruco.Dictionary_nbits(self)

    def tau(self) -> "uint32_t":
        return _pyaruco.Dictionary_tau(self)

    def getName(self) -> "std::string":
        return _pyaruco.Dictionary_getName(self)

    def getMapCode(self) -> "std::map< uint64_t,uint16_t > const &":
        return _pyaruco.Dictionary_getMapCode(self)

    def at(self, code: 'uint64_t') -> "int":
        return _pyaruco.Dictionary_at(self, code)

    def getMarkerImage_id(self, id: 'int', bit_size: 'int', addWaterMark: 'bool'=True, enclosed_corners: 'bool'=False, printExternalWhiteBorder: 'bool'=False, centralCircle: 'bool'=False) -> "cv::Mat":
        return _pyaruco.Dictionary_getMarkerImage_id(self, id, bit_size, addWaterMark, enclosed_corners, printExternalWhiteBorder, centralCircle)

    def createMarkerMap(self, gridSize: 'cv::Size', MarkerSize: 'int', MarkerDistance: 'int', Ids: 'VectorInt', chess_board: 'bool'=False) -> "aruco::MarkerMap":
        return _pyaruco.Dictionary_createMarkerMap(self, gridSize, MarkerSize, MarkerDistance, Ids, chess_board)
    if _newclass:
        loadPredefined = staticmethod(_pyaruco.Dictionary_loadPredefined)
    else:
        loadPredefined = _pyaruco.Dictionary_loadPredefined
    if _newclass:
        loadFromFile = staticmethod(_pyaruco.Dictionary_loadFromFile)
    else:
        loadFromFile = _pyaruco.Dictionary_loadFromFile
    if _newclass:
        load = staticmethod(_pyaruco.Dictionary_load)
    else:
        load = _pyaruco.Dictionary_load
    if _newclass:
        computeDictionaryDistance = staticmethod(_pyaruco.Dictionary_computeDictionaryDistance)
    else:
        computeDictionaryDistance = _pyaruco.Dictionary_computeDictionaryDistance
    if _newclass:
        getTypeFromString = staticmethod(_pyaruco.Dictionary_getTypeFromString)
    else:
        getTypeFromString = _pyaruco.Dictionary_getTypeFromString
    if _newclass:
        getTypeString = staticmethod(_pyaruco.Dictionary_getTypeString)
    else:
        getTypeString = _pyaruco.Dictionary_getTypeString
    if _newclass:
        isPredefinedDictinaryString = staticmethod(_pyaruco.Dictionary_isPredefinedDictinaryString)
    else:
        isPredefinedDictinaryString = _pyaruco.Dictionary_isPredefinedDictinaryString
    if _newclass:
        getDicTypes = staticmethod(_pyaruco.Dictionary_getDicTypes)
    else:
        getDicTypes = _pyaruco.Dictionary_getDicTypes

    def __init__(self):
        this = _pyaruco.new_Dictionary()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_Dictionary
    __del__ = lambda self: None
Dictionary_swigregister = _pyaruco.Dictionary_swigregister
Dictionary_swigregister(Dictionary)

def Dictionary_loadPredefined(*args) -> "aruco::Dictionary":
    return _pyaruco.Dictionary_loadPredefined(*args)
Dictionary_loadPredefined = _pyaruco.Dictionary_loadPredefined

def Dictionary_loadFromFile(path: 'std::string') -> "aruco::Dictionary":
    return _pyaruco.Dictionary_loadFromFile(path)
Dictionary_loadFromFile = _pyaruco.Dictionary_loadFromFile

def Dictionary_load(info: 'std::string') -> "aruco::Dictionary":
    return _pyaruco.Dictionary_load(info)
Dictionary_load = _pyaruco.Dictionary_load

def Dictionary_computeDictionaryDistance(d: 'Dictionary') -> "uint64_t":
    return _pyaruco.Dictionary_computeDictionaryDistance(d)
Dictionary_computeDictionaryDistance = _pyaruco.Dictionary_computeDictionaryDistance

def Dictionary_getTypeFromString(str: 'std::string') -> "aruco::Dictionary::DICT_TYPES":
    return _pyaruco.Dictionary_getTypeFromString(str)
Dictionary_getTypeFromString = _pyaruco.Dictionary_getTypeFromString

def Dictionary_getTypeString(t: 'aruco::Dictionary::DICT_TYPES') -> "std::string":
    return _pyaruco.Dictionary_getTypeString(t)
Dictionary_getTypeString = _pyaruco.Dictionary_getTypeString

def Dictionary_isPredefinedDictinaryString(str: 'std::string') -> "bool":
    return _pyaruco.Dictionary_isPredefinedDictinaryString(str)
Dictionary_isPredefinedDictinaryString = _pyaruco.Dictionary_isPredefinedDictinaryString

def Dictionary_getDicTypes() -> "std::vector< std::string,std::allocator< std::string > >":
    return _pyaruco.Dictionary_getDicTypes()
Dictionary_getDicTypes = _pyaruco.Dictionary_getDicTypes

class Marker(Point2fVec):
    __swig_setmethods__ = {}
    for _s in [Point2fVec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Marker, name, value)
    __swig_getmethods__ = {}
    for _s in [Point2fVec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Marker, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _pyaruco.Marker_id_set
    __swig_getmethods__["id"] = _pyaruco.Marker_id_get
    if _newclass:
        id = _swig_property(_pyaruco.Marker_id_get, _pyaruco.Marker_id_set)
    __swig_setmethods__["ssize"] = _pyaruco.Marker_ssize_set
    __swig_getmethods__["ssize"] = _pyaruco.Marker_ssize_get
    if _newclass:
        ssize = _swig_property(_pyaruco.Marker_ssize_get, _pyaruco.Marker_ssize_set)
    __swig_setmethods__["Rvec"] = _pyaruco.Marker_Rvec_set
    __swig_getmethods__["Rvec"] = _pyaruco.Marker_Rvec_get
    if _newclass:
        Rvec = _swig_property(_pyaruco.Marker_Rvec_get, _pyaruco.Marker_Rvec_set)
    __swig_setmethods__["Tvec"] = _pyaruco.Marker_Tvec_set
    __swig_getmethods__["Tvec"] = _pyaruco.Marker_Tvec_get
    if _newclass:
        Tvec = _swig_property(_pyaruco.Marker_Tvec_get, _pyaruco.Marker_Tvec_set)
    __swig_setmethods__["dict_info"] = _pyaruco.Marker_dict_info_set
    __swig_getmethods__["dict_info"] = _pyaruco.Marker_dict_info_get
    if _newclass:
        dict_info = _swig_property(_pyaruco.Marker_dict_info_get, _pyaruco.Marker_dict_info_set)
    __swig_setmethods__["contourPoints"] = _pyaruco.Marker_contourPoints_set
    __swig_getmethods__["contourPoints"] = _pyaruco.Marker_contourPoints_get
    if _newclass:
        contourPoints = _swig_property(_pyaruco.Marker_contourPoints_get, _pyaruco.Marker_contourPoints_set)

    def __init__(self, *args):
        this = _pyaruco.new_Marker(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_Marker
    __del__ = lambda self: None

    def isValid(self) -> "bool":
        return _pyaruco.Marker_isValid(self)

    def isPoseValid(self) -> "bool":
        return _pyaruco.Marker_isPoseValid(self)

    def draw(self, *args) -> "void":
        return _pyaruco.Marker_draw(self, *args)

    def calculateExtrinsics(self, *args) -> "void":
        return _pyaruco.Marker_calculateExtrinsics(self, *args)

    def glGetModelViewMatrix(self, modelview_matrix: 'double [16]') -> "void":
        return _pyaruco.Marker_glGetModelViewMatrix(self, modelview_matrix)

    def OgreGetPoseParameters(self, position: 'double [3]', orientation: 'double [4]') -> "void":
        return _pyaruco.Marker_OgreGetPoseParameters(self, position, orientation)

    def getCenter(self) -> "cv::Point2f":
        return _pyaruco.Marker_getCenter(self)

    def getPerimeter(self) -> "float":
        return _pyaruco.Marker_getPerimeter(self)

    def getArea(self) -> "float":
        return _pyaruco.Marker_getArea(self)

    def getRadius(self) -> "float":
        return _pyaruco.Marker_getRadius(self)

    def __eq__(self, m: 'Marker') -> "bool":
        return _pyaruco.Marker___eq__(self, m)

    def copyTo(self, m: 'Marker') -> "void":
        return _pyaruco.Marker_copyTo(self, m)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _pyaruco.Marker_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _pyaruco.Marker_fromStream(self, str)

    def get3DPoints(self, *args) -> "vector< cv::Point3f >":
        return _pyaruco.Marker_get3DPoints(self, *args)

    def getTransformMatrix(self) -> "cv::Mat":
        return _pyaruco.Marker_getTransformMatrix(self)

    def __getitem__(self, i: 'int') -> "cv::Point2f":
        return _pyaruco.Marker___getitem__(self, i)

    def __len__(self) -> "int":
        return _pyaruco.Marker___len__(self)

    def __iter__(self):
        return VectorIterator(self)

Marker_swigregister = _pyaruco.Marker_swigregister
Marker_swigregister(Marker)


class VectorIterator(object):

    def __init__(self, pointerToVector):
        self.pointerToVector = pointerToVector
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1
        if self.index < len(self.pointerToVector):
            return self.pointerToVector[self.index]
        else:
            raise StopIteration

    def next(self):
        self.index += 1
        if self.index < len(self.pointerToVector):
            return self.pointerToVector[self.index]
        else:
            raise StopIteration

DM_NORMAL = _pyaruco.DM_NORMAL
DM_FAST = _pyaruco.DM_FAST
DM_VIDEO_FAST = _pyaruco.DM_VIDEO_FAST
CORNER_SUBPIX = _pyaruco.CORNER_SUBPIX
CORNER_LINES = _pyaruco.CORNER_LINES
CORNER_NONE = _pyaruco.CORNER_NONE
class MarkerDetector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerDetector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerDetector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _pyaruco.new_MarkerDetector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def saveParamsToFile(self, path: 'std::string const &') -> "void":
        return _pyaruco.MarkerDetector_saveParamsToFile(self, path)

    def loadParamsFromFile(self, path: 'std::string const &') -> "void":
        return _pyaruco.MarkerDetector_loadParamsFromFile(self, path)
    __swig_destroy__ = _pyaruco.delete_MarkerDetector
    __del__ = lambda self: None

    def setDetectionMode(self, dm: 'aruco::DetectionMode', minMarkerSize: 'float'=0) -> "void":
        return _pyaruco.MarkerDetector_setDetectionMode(self, dm, minMarkerSize)

    def getDetectionMode(self) -> "aruco::DetectionMode":
        return _pyaruco.MarkerDetector_getDetectionMode(self)

    def detect(self, *args) -> "void":
        return _pyaruco.MarkerDetector_detect(self, *args)

    def getParameters(self, *args) -> "aruco::MarkerDetector::Params &":
        return _pyaruco.MarkerDetector_getParameters(self, *args)

    def setDictionary(self, *args) -> "void":
        return _pyaruco.MarkerDetector_setDictionary(self, *args)

    def getThresholdedImage(self, idx: 'uint32_t'=0) -> "cv::Mat":
        return _pyaruco.MarkerDetector_getThresholdedImage(self, idx)

    def setMarkerLabeler(self, detector: 'cv::Ptr< aruco::MarkerLabeler >') -> "void":
        return _pyaruco.MarkerDetector_setMarkerLabeler(self, detector)

    def getMarkerLabeler(self) -> "cv::Ptr< aruco::MarkerLabeler >":
        return _pyaruco.MarkerDetector_getMarkerLabeler(self)

    def getCandidates(self) -> "std::vector< aruco::MarkerCandidate,std::allocator< aruco::MarkerCandidate > >":
        return _pyaruco.MarkerDetector_getCandidates(self)

    def getImagePyramid(self) -> "std::vector< cv::Mat,std::allocator< cv::Mat > >":
        return _pyaruco.MarkerDetector_getImagePyramid(self)

    def cornerUpsample(self, corners: 'std::vector< std::vector< cv::Point2f,std::allocator< cv::Point2f > >,std::allocator< std::vector< cv::Point2f,std::allocator< cv::Point2f > > > > &', lowResImageSize: 'cv::Size') -> "void":
        return _pyaruco.MarkerDetector_cornerUpsample(self, corners, lowResImageSize)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _pyaruco.MarkerDetector_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _pyaruco.MarkerDetector_fromStream(self, str)

    def setParameters(self, params: 'aruco::MarkerDetector::Params const &') -> "void":
        return _pyaruco.MarkerDetector_setParameters(self, params)
MarkerDetector_swigregister = _pyaruco.MarkerDetector_swigregister
MarkerDetector_swigregister(MarkerDetector)

class MarkerDetector_Impl(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerDetector_Impl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerDetector_Impl, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _pyaruco.new_MarkerDetector_Impl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def saveParamsToFile(self, path: 'std::string const &') -> "void":
        return _pyaruco.MarkerDetector_Impl_saveParamsToFile(self, path)

    def loadParamsFromFile(self, path: 'std::string const &') -> "void":
        return _pyaruco.MarkerDetector_Impl_loadParamsFromFile(self, path)
    __swig_destroy__ = _pyaruco.delete_MarkerDetector_Impl
    __del__ = lambda self: None

    def setDetectionMode(self, dm: 'aruco::DetectionMode', minMarkerSize: 'float'=0) -> "void":
        return _pyaruco.MarkerDetector_Impl_setDetectionMode(self, dm, minMarkerSize)

    def getDetectionMode(self) -> "aruco::DetectionMode":
        return _pyaruco.MarkerDetector_Impl_getDetectionMode(self)

    def detect(self, *args) -> "void":
        return _pyaruco.MarkerDetector_Impl_detect(self, *args)

    def getParameters(self, *args) -> "aruco::MarkerDetector::Params &":
        return _pyaruco.MarkerDetector_Impl_getParameters(self, *args)

    def setDictionary(self, *args) -> "void":
        return _pyaruco.MarkerDetector_Impl_setDictionary(self, *args)

    def getThresholdedImage(self, idx: 'uint32_t'=0) -> "cv::Mat":
        return _pyaruco.MarkerDetector_Impl_getThresholdedImage(self, idx)

    def setMarkerLabeler(self, detector: 'cv::Ptr< aruco::MarkerLabeler >') -> "void":
        return _pyaruco.MarkerDetector_Impl_setMarkerLabeler(self, detector)

    def getMarkerLabeler(self) -> "cv::Ptr< aruco::MarkerLabeler >":
        return _pyaruco.MarkerDetector_Impl_getMarkerLabeler(self)

    def getCandidates(self) -> "std::vector< aruco::MarkerDetector_Impl::MarkerCandidate,std::allocator< aruco::MarkerDetector_Impl::MarkerCandidate > >":
        return _pyaruco.MarkerDetector_Impl_getCandidates(self)

    def warp(self, arg2: 'cv::Mat &', out: 'cv::Mat &', size: 'cv::Size', points: 'Point2fVec') -> "bool":
        return _pyaruco.MarkerDetector_Impl_warp(self, arg2, out, size, points)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _pyaruco.MarkerDetector_Impl_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _pyaruco.MarkerDetector_Impl_fromStream(self, str)

    def setParameters(self, params: 'aruco::MarkerDetector::Params const &') -> "void":
        return _pyaruco.MarkerDetector_Impl_setParameters(self, params)

    def getImagePyramid(self) -> "std::vector< cv::Mat,std::allocator< cv::Mat > >":
        return _pyaruco.MarkerDetector_Impl_getImagePyramid(self)
MarkerDetector_Impl_swigregister = _pyaruco.MarkerDetector_Impl_swigregister
MarkerDetector_Impl_swigregister(MarkerDetector_Impl)

class MarkerLabeler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerLabeler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerLabeler, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_pyaruco.MarkerLabeler_create)
    else:
        create = _pyaruco.MarkerLabeler_create

    def detect(self, arg2: 'cv::Mat const &', marker_id: 'int &', nRotations: 'int &', additionalInfo: 'std::string &') -> "bool":
        return _pyaruco.MarkerLabeler_detect(self, arg2, marker_id, nRotations, additionalInfo)

    def getBestInputSize(self) -> "int":
        return _pyaruco.MarkerLabeler_getBestInputSize(self)

    def getNSubdivisions(self) -> "int":
        return _pyaruco.MarkerLabeler_getNSubdivisions(self)

    def getName(self) -> "std::string":
        return _pyaruco.MarkerLabeler_getName(self)
    __swig_destroy__ = _pyaruco.delete_MarkerLabeler
    __del__ = lambda self: None
MarkerLabeler_swigregister = _pyaruco.MarkerLabeler_swigregister
MarkerLabeler_swigregister(MarkerLabeler)

def MarkerLabeler_create(*args) -> "cv::Ptr< aruco::MarkerLabeler >":
    return _pyaruco.MarkerLabeler_create(*args)
MarkerLabeler_create = _pyaruco.MarkerLabeler_create

class FractalDetector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FractalDetector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FractalDetector, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _pyaruco.new_FractalDetector()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setConfiguration(self, *args) -> "void":
        return _pyaruco.FractalDetector_setConfiguration(self, *args)

    def setParams(self, cam_params: 'CameraParameters', markerSize: 'float') -> "void":
        return _pyaruco.FractalDetector_setParams(self, cam_params, markerSize)

    def getConfiguration(self) -> "FractalMarkerSet":
        return _pyaruco.FractalDetector_getConfiguration(self)

    def detect(self, input: 'cv::Mat const &') -> "bool":
        return _pyaruco.FractalDetector_detect(self, input)

    def poseEstimation(self) -> "bool":
        return _pyaruco.FractalDetector_poseEstimation(self)

    def getRvec(self) -> "cv::Mat":
        return _pyaruco.FractalDetector_getRvec(self)

    def getTvec(self) -> "cv::Mat":
        return _pyaruco.FractalDetector_getTvec(self)

    def drawMarkers(self, img: 'cv::Mat &') -> "void":
        return _pyaruco.FractalDetector_drawMarkers(self, img)

    def draw2d(self, img: 'cv::Mat &') -> "void":
        return _pyaruco.FractalDetector_draw2d(self, img)

    def draw3d(self, img: 'cv::Mat &', cube: 'bool'=True, axis: 'bool'=True) -> "void":
        return _pyaruco.FractalDetector_draw3d(self, img, cube, axis)

    def draw3dCube(self, Image: 'cv::Mat &', m: 'FractalMarker', CP: 'CameraParameters', lineSize: 'int') -> "void":
        return _pyaruco.FractalDetector_draw3dCube(self, Image, m, CP, lineSize)

    def getMarkers(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >":
        return _pyaruco.FractalDetector_getMarkers(self)
    __swig_destroy__ = _pyaruco.delete_FractalDetector
    __del__ = lambda self: None
FractalDetector_swigregister = _pyaruco.FractalDetector_swigregister
FractalDetector_swigregister(FractalDetector)

class Marker3DInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Marker3DInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Marker3DInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["points"] = _pyaruco.Marker3DInfo_points_set
    __swig_getmethods__["points"] = _pyaruco.Marker3DInfo_points_get
    if _newclass:
        points = _swig_property(_pyaruco.Marker3DInfo_points_get, _pyaruco.Marker3DInfo_points_set)
    __swig_setmethods__["id"] = _pyaruco.Marker3DInfo_id_set
    __swig_getmethods__["id"] = _pyaruco.Marker3DInfo_id_get
    if _newclass:
        id = _swig_property(_pyaruco.Marker3DInfo_id_get, _pyaruco.Marker3DInfo_id_set)

    def __init__(self, *args):
        this = _pyaruco.new_Marker3DInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, MI: 'Marker3DInfo') -> "bool":
        return _pyaruco.Marker3DInfo___eq__(self, MI)

    def getMarkerSize(self) -> "float":
        return _pyaruco.Marker3DInfo_getMarkerSize(self)

    def at(self, idx: 'size_t') -> "cv::Point3f":
        return _pyaruco.Marker3DInfo_at(self, idx)

    def push_back(self, p: 'cv::Point3f const &') -> "void":
        return _pyaruco.Marker3DInfo_push_back(self, p)

    def size(self) -> "size_t":
        return _pyaruco.Marker3DInfo_size(self)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _pyaruco.Marker3DInfo_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _pyaruco.Marker3DInfo_fromStream(self, str)
    __swig_destroy__ = _pyaruco.delete_Marker3DInfo
    __del__ = lambda self: None
Marker3DInfo_swigregister = _pyaruco.Marker3DInfo_swigregister
Marker3DInfo_swigregister(Marker3DInfo)

class MarkerMap(VectorMarker3DInfo):
    __swig_setmethods__ = {}
    for _s in [VectorMarker3DInfo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerMap, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorMarker3DInfo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerMap, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _pyaruco.new_MarkerMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isExpressedInMeters(self) -> "bool":
        return _pyaruco.MarkerMap_isExpressedInMeters(self)

    def isExpressedInPixels(self) -> "bool":
        return _pyaruco.MarkerMap_isExpressedInPixels(self)

    def convertToMeters(self, markerSize: 'float') -> "aruco::MarkerMap":
        return _pyaruco.MarkerMap_convertToMeters(self, markerSize)

    def getIndices(self, markers: 'vector< aruco::Marker > const &') -> "std::vector< int,std::allocator< int > >":
        return _pyaruco.MarkerMap_getIndices(self, markers)

    def getMarker3DInfo(self, id: 'int') -> "aruco::Marker3DInfo const &":
        return _pyaruco.MarkerMap_getMarker3DInfo(self, id)

    def getIndexOfMarkerId(self, id: 'int') -> "int":
        return _pyaruco.MarkerMap_getIndexOfMarkerId(self, id)

    def getIdList(self, ids: 'vector< int > &', append: 'bool'=True) -> "void":
        return _pyaruco.MarkerMap_getIdList(self, ids, append)

    def getImage(self, METER2PIX: 'float'=0) -> "cv::Mat":
        return _pyaruco.MarkerMap_getImage(self, METER2PIX)

    def saveToFile(self, sfile: 'std::string') -> "void":
        return _pyaruco.MarkerMap_saveToFile(self, sfile)

    def readFromFile(self, sfile: 'std::string') -> "void":
        return _pyaruco.MarkerMap_readFromFile(self, sfile)

    def calculateExtrinsics(self, markers: 'MarkerPoint3fVecVec', markerSize: 'float', CameraMatrix: 'cv::Mat', Distorsion: 'cv::Mat') -> "std::pair< cv::Mat,cv::Mat >":
        return _pyaruco.MarkerMap_calculateExtrinsics(self, markers, markerSize, CameraMatrix, Distorsion)

    def getDictionary(self) -> "std::string":
        return _pyaruco.MarkerMap_getDictionary(self)
    NONE = _pyaruco.MarkerMap_NONE
    PIX = _pyaruco.MarkerMap_PIX
    METERS = _pyaruco.MarkerMap_METERS

    def setDictionary(self, d: 'std::string') -> "void":
        return _pyaruco.MarkerMap_setDictionary(self, d)
    __swig_setmethods__["mInfoType"] = _pyaruco.MarkerMap_mInfoType_set
    __swig_getmethods__["mInfoType"] = _pyaruco.MarkerMap_mInfoType_get
    if _newclass:
        mInfoType = _swig_property(_pyaruco.MarkerMap_mInfoType_get, _pyaruco.MarkerMap_mInfoType_set)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _pyaruco.MarkerMap_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _pyaruco.MarkerMap_fromStream(self, str)
    __swig_destroy__ = _pyaruco.delete_MarkerMap
    __del__ = lambda self: None
MarkerMap_swigregister = _pyaruco.MarkerMap_swigregister
MarkerMap_swigregister(MarkerMap)

class L2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, L2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, L2, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _pyaruco.new_L2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_L2
    __del__ = lambda self: None
L2_swigregister = _pyaruco.L2_swigregister
L2_swigregister(L2)

class MarkerPoseTracker(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerPoseTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerPoseTracker, name)
    __repr__ = _swig_repr

    def estimatePose(self, m: 'Marker', cam_params: 'CameraParameters', markerSize: 'float', minErrorRatio: 'float'=10) -> "bool":
        return _pyaruco.MarkerPoseTracker_estimatePose(self, m, cam_params, markerSize, minErrorRatio)

    def getRTMatrix(self) -> "cv::Mat":
        return _pyaruco.MarkerPoseTracker_getRTMatrix(self)

    def getRvec(self) -> "cv::Mat const":
        return _pyaruco.MarkerPoseTracker_getRvec(self)

    def getTvec(self) -> "cv::Mat const":
        return _pyaruco.MarkerPoseTracker_getTvec(self)

    def __init__(self):
        this = _pyaruco.new_MarkerPoseTracker()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_MarkerPoseTracker
    __del__ = lambda self: None
MarkerPoseTracker_swigregister = _pyaruco.MarkerPoseTracker_swigregister
MarkerPoseTracker_swigregister(MarkerPoseTracker)

class MarkerMapPoseTracker(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerMapPoseTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerMapPoseTracker, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _pyaruco.new_MarkerMapPoseTracker()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setParams(self, cam_params: 'CameraParameters', msconf: 'MarkerMap', markerSize: 'float'=-1) -> "void":
        return _pyaruco.MarkerMapPoseTracker_setParams(self, cam_params, msconf, markerSize)

    def isValid(self) -> "bool":
        return _pyaruco.MarkerMapPoseTracker_isValid(self)

    def reset(self) -> "void":
        return _pyaruco.MarkerMapPoseTracker_reset(self)

    def estimatePose(self, v_m: 'MarkerPoint3fVecVec') -> "bool":
        return _pyaruco.MarkerMapPoseTracker_estimatePose(self, v_m)

    def getRTMatrix(self) -> "cv::Mat":
        return _pyaruco.MarkerMapPoseTracker_getRTMatrix(self)

    def getRvec(self) -> "cv::Mat const":
        return _pyaruco.MarkerMapPoseTracker_getRvec(self)

    def getTvec(self) -> "cv::Mat const":
        return _pyaruco.MarkerMapPoseTracker_getTvec(self)

    def setMaxTrackingDifference(self, maxTranslation: 'float', maxAngle: 'float') -> "void":
        return _pyaruco.MarkerMapPoseTracker_setMaxTrackingDifference(self, maxTranslation, maxAngle)
    __swig_destroy__ = _pyaruco.delete_MarkerMapPoseTracker
    __del__ = lambda self: None
MarkerMapPoseTracker_swigregister = _pyaruco.MarkerMapPoseTracker_swigregister
MarkerMapPoseTracker_swigregister(MarkerMapPoseTracker)

class PicoFlann_KeyPointAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PicoFlann_KeyPointAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PicoFlann_KeyPointAdapter, name)
    __repr__ = _swig_repr

    def __call__(self, *args) -> "float":
        return _pyaruco.PicoFlann_KeyPointAdapter___call__(self, *args)

    def __init__(self):
        this = _pyaruco.new_PicoFlann_KeyPointAdapter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_PicoFlann_KeyPointAdapter
    __del__ = lambda self: None
PicoFlann_KeyPointAdapter_swigregister = _pyaruco.PicoFlann_KeyPointAdapter_swigregister
PicoFlann_KeyPointAdapter_swigregister(PicoFlann_KeyPointAdapter)

class FractalPoseTracker(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FractalPoseTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FractalPoseTracker, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _pyaruco.new_FractalPoseTracker()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setParams(self, cam_params: 'CameraParameters', msconf: 'FractalMarkerSet const &', markerSize: 'float const'=-1) -> "void":
        return _pyaruco.FractalPoseTracker_setParams(self, cam_params, msconf, markerSize)

    def fractalInnerPose(self, markerDetector: 'cv::Ptr< aruco::MarkerDetector > const', markers: 'MarkerPoint3fVecVec', refinement: 'bool'=True) -> "bool":
        return _pyaruco.FractalPoseTracker_fractalInnerPose(self, markerDetector, markers, refinement)

    def ROI(self, imagePyramid: 'std::vector< cv::Mat,std::allocator< cv::Mat > > const', img: 'cv::Mat &', innerPoints2d: 'Point2fVec', offset: 'cv::Point2f &', ratio: 'float &') -> "bool":
        return _pyaruco.FractalPoseTracker_ROI(self, imagePyramid, img, innerPoints2d, offset, ratio)

    def assignClass(self, im: 'cv::Mat const &', kpoints: 'std::vector< cv::KeyPoint,std::allocator< cv::KeyPoint > > &', transf: 'bool'=False, wsize: 'int'=5) -> "void":
        return _pyaruco.FractalPoseTracker_assignClass(self, im, kpoints, transf, wsize)

    def fractal_solve_ransac(self, ninners: 'int', inner_kpnt: 'std::vector< std::pair< uint,std::vector< uint,std::allocator< uint > > >,std::allocator< std::pair< uint,std::vector< uint,std::allocator< uint > > > > >', kpnts: 'std::vector< cv::KeyPoint,std::allocator< cv::KeyPoint > >', maxIter: 'uint32_t'=500, _minInliers: 'float'=0.2, _thresInliers: 'float'=0.7) -> "cv::Mat":
        return _pyaruco.FractalPoseTracker_fractal_solve_ransac(self, ninners, inner_kpnt, kpnts, maxIter, _minInliers, _thresInliers)

    def drawKeyPoints(self, image: 'cv::Mat const', kpoints: 'std::vector< cv::KeyPoint,std::allocator< cv::KeyPoint > >', text: 'bool'=False, transf: 'bool'=False) -> "void":
        return _pyaruco.FractalPoseTracker_drawKeyPoints(self, image, kpoints, text, transf)

    def fractalRefinement(self, markerDetector: 'cv::Ptr< aruco::MarkerDetector > const', markerWarpPix: 'int'=10) -> "bool":
        return _pyaruco.FractalPoseTracker_fractalRefinement(self, markerDetector, markerWarpPix)

    def getRvec(self) -> "cv::Mat const":
        return _pyaruco.FractalPoseTracker_getRvec(self)

    def getTvec(self) -> "cv::Mat const":
        return _pyaruco.FractalPoseTracker_getTvec(self)

    def getInner3d(self) -> "std::vector< cv::Point3f,std::allocator< cv::Point3f > > const":
        return _pyaruco.FractalPoseTracker_getInner3d(self)

    def isPoseValid(self) -> "bool":
        return _pyaruco.FractalPoseTracker_isPoseValid(self)

    def getFractal(self) -> "FractalMarkerSet":
        return _pyaruco.FractalPoseTracker_getFractal(self)
    __swig_destroy__ = _pyaruco.delete_FractalPoseTracker
    __del__ = lambda self: None
FractalPoseTracker_swigregister = _pyaruco.FractalPoseTracker_swigregister
FractalPoseTracker_swigregister(FractalPoseTracker)

class FractalMarkerLabeler(MarkerLabeler):
    __swig_setmethods__ = {}
    for _s in [MarkerLabeler]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FractalMarkerLabeler, name, value)
    __swig_getmethods__ = {}
    for _s in [MarkerLabeler]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FractalMarkerLabeler, name)
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_pyaruco.FractalMarkerLabeler_create)
    else:
        create = _pyaruco.FractalMarkerLabeler_create

    def setConfiguration(self, fractMarkerSet: 'FractalMarkerSet const &') -> "void":
        return _pyaruco.FractalMarkerLabeler_setConfiguration(self, fractMarkerSet)
    __swig_destroy__ = _pyaruco.delete_FractalMarkerLabeler
    __del__ = lambda self: None

    def getName(self) -> "std::string":
        return _pyaruco.FractalMarkerLabeler_getName(self)

    def detect(self, arg2: 'cv::Mat const &', marker_id: 'int &', nRotations: 'int &', additionalInfo: 'std::string &') -> "bool":
        return _pyaruco.FractalMarkerLabeler_detect(self, arg2, marker_id, nRotations, additionalInfo)

    def getNSubdivisions(self) -> "int":
        return _pyaruco.FractalMarkerLabeler_getNSubdivisions(self)
    __swig_setmethods__["_fractalMarkerSet"] = _pyaruco.FractalMarkerLabeler__fractalMarkerSet_set
    __swig_getmethods__["_fractalMarkerSet"] = _pyaruco.FractalMarkerLabeler__fractalMarkerSet_get
    if _newclass:
        _fractalMarkerSet = _swig_property(_pyaruco.FractalMarkerLabeler__fractalMarkerSet_get, _pyaruco.FractalMarkerLabeler__fractalMarkerSet_set)

    def __init__(self):
        this = _pyaruco.new_FractalMarkerLabeler()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
FractalMarkerLabeler_swigregister = _pyaruco.FractalMarkerLabeler_swigregister
FractalMarkerLabeler_swigregister(FractalMarkerLabeler)

def FractalMarkerLabeler_create(*args) -> "cv::Ptr< aruco::FractalMarkerLabeler >":
    return _pyaruco.FractalMarkerLabeler_create(*args)
FractalMarkerLabeler_create = _pyaruco.FractalMarkerLabeler_create

class FractalMarkerSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FractalMarkerSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FractalMarkerSet, name)
    __repr__ = _swig_repr
    FRACTAL_2L_6 = _pyaruco.FractalMarkerSet_FRACTAL_2L_6
    FRACTAL_3L_6 = _pyaruco.FractalMarkerSet_FRACTAL_3L_6
    FRACTAL_4L_6 = _pyaruco.FractalMarkerSet_FRACTAL_4L_6
    FRACTAL_5L_6 = _pyaruco.FractalMarkerSet_FRACTAL_5L_6
    CUSTOM = _pyaruco.FractalMarkerSet_CUSTOM

    def create(self, regionsConfig: 'std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >', pixSize: 'float') -> "void":
        return _pyaruco.FractalMarkerSet_create(self, regionsConfig, pixSize)

    def configureMat(self, nVal: 'int', kVal: 'int', maxIter: 'int'=10000) -> "cv::Mat":
        return _pyaruco.FractalMarkerSet_configureMat(self, nVal, kVal, maxIter)

    def dstMarker(self, m: 'cv::Mat const') -> "int":
        return _pyaruco.FractalMarkerSet_dstMarker(self, m)

    def dstMarkerToMarker(self, m1: 'cv::Mat const', m2: 'cv::Mat const') -> "int":
        return _pyaruco.FractalMarkerSet_dstMarkerToMarker(self, m1, m2)

    def dstMarkerToFractalDict(self, m: 'cv::Mat') -> "int":
        return _pyaruco.FractalMarkerSet_dstMarkerToFractalDict(self, m)
    if _newclass:
        _toStream = staticmethod(_pyaruco.FractalMarkerSet__toStream)
    else:
        _toStream = _pyaruco.FractalMarkerSet__toStream
    if _newclass:
        _fromStream = staticmethod(_pyaruco.FractalMarkerSet__fromStream)
    else:
        _fromStream = _pyaruco.FractalMarkerSet__fromStream
    if _newclass:
        isPredefinedConfigurationString = staticmethod(_pyaruco.FractalMarkerSet_isPredefinedConfigurationString)
    else:
        isPredefinedConfigurationString = _pyaruco.FractalMarkerSet_isPredefinedConfigurationString
    if _newclass:
        getTypeString = staticmethod(_pyaruco.FractalMarkerSet_getTypeString)
    else:
        getTypeString = _pyaruco.FractalMarkerSet_getTypeString
    if _newclass:
        getTypeFromString = staticmethod(_pyaruco.FractalMarkerSet_getTypeFromString)
    else:
        getTypeFromString = _pyaruco.FractalMarkerSet_getTypeFromString
    if _newclass:
        load = staticmethod(_pyaruco.FractalMarkerSet_load)
    else:
        load = _pyaruco.FractalMarkerSet_load
    if _newclass:
        loadPredefined = staticmethod(_pyaruco.FractalMarkerSet_loadPredefined)
    else:
        loadPredefined = _pyaruco.FractalMarkerSet_loadPredefined
    if _newclass:
        readFromFile = staticmethod(_pyaruco.FractalMarkerSet_readFromFile)
    else:
        readFromFile = _pyaruco.FractalMarkerSet_readFromFile

    def saveToFile(self, fs: 'cv::FileStorage &') -> "void":
        return _pyaruco.FractalMarkerSet_saveToFile(self, fs)
    __swig_setmethods__["fractalMarkerCollection"] = _pyaruco.FractalMarkerSet_fractalMarkerCollection_set
    __swig_getmethods__["fractalMarkerCollection"] = _pyaruco.FractalMarkerSet_fractalMarkerCollection_get
    if _newclass:
        fractalMarkerCollection = _swig_property(_pyaruco.FractalMarkerSet_fractalMarkerCollection_get, _pyaruco.FractalMarkerSet_fractalMarkerCollection_set)
    __swig_setmethods__["nbits_fractalMarkerIDs"] = _pyaruco.FractalMarkerSet_nbits_fractalMarkerIDs_set
    __swig_getmethods__["nbits_fractalMarkerIDs"] = _pyaruco.FractalMarkerSet_nbits_fractalMarkerIDs_get
    if _newclass:
        nbits_fractalMarkerIDs = _swig_property(_pyaruco.FractalMarkerSet_nbits_fractalMarkerIDs_get, _pyaruco.FractalMarkerSet_nbits_fractalMarkerIDs_set)
    NONE = _pyaruco.FractalMarkerSet_NONE
    PIX = _pyaruco.FractalMarkerSet_PIX
    METERS = _pyaruco.FractalMarkerSet_METERS
    NORM = _pyaruco.FractalMarkerSet_NORM

    def isExpressedInMeters(self) -> "bool":
        return _pyaruco.FractalMarkerSet_isExpressedInMeters(self)

    def isExpressedInPixels(self) -> "bool":
        return _pyaruco.FractalMarkerSet_isExpressedInPixels(self)

    def isNormalize(self) -> "bool":
        return _pyaruco.FractalMarkerSet_isNormalize(self)

    def normalize(self) -> "aruco::FractalMarkerSet":
        return _pyaruco.FractalMarkerSet_normalize(self)

    def convertToMeters(self, fractalSize_meters: 'float') -> "aruco::FractalMarkerSet":
        return _pyaruco.FractalMarkerSet_convertToMeters(self, fractalSize_meters)
    if _newclass:
        getConfigurations = staticmethod(_pyaruco.FractalMarkerSet_getConfigurations)
    else:
        getConfigurations = _pyaruco.FractalMarkerSet_getConfigurations

    def getFractalSize(self) -> "float":
        return _pyaruco.FractalMarkerSet_getFractalSize(self)

    def nBits(self) -> "int":
        return _pyaruco.FractalMarkerSet_nBits(self)

    def isFractalMarker(self, m: 'cv::Mat &', nbits: 'int', id: 'int &') -> "bool":
        return _pyaruco.FractalMarkerSet_isFractalMarker(self, m, nbits, id)

    def getInnerCorners(self) -> "std::map< int,std::vector< cv::Point3f,std::allocator< cv::Point3f > > >":
        return _pyaruco.FractalMarkerSet_getInnerCorners(self)

    def getFractalMarkerImage(self, pixSize: 'int', border: 'bool'=False) -> "cv::Mat":
        return _pyaruco.FractalMarkerSet_getFractalMarkerImage(self, pixSize, border)
    __swig_setmethods__["mInfoType"] = _pyaruco.FractalMarkerSet_mInfoType_set
    __swig_getmethods__["mInfoType"] = _pyaruco.FractalMarkerSet_mInfoType_get
    if _newclass:
        mInfoType = _swig_property(_pyaruco.FractalMarkerSet_mInfoType_get, _pyaruco.FractalMarkerSet_mInfoType_set)

    def __init__(self):
        this = _pyaruco.new_FractalMarkerSet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_FractalMarkerSet
    __del__ = lambda self: None
FractalMarkerSet_swigregister = _pyaruco.FractalMarkerSet_swigregister
FractalMarkerSet_swigregister(FractalMarkerSet)

def FractalMarkerSet__toStream(configuration: 'FractalMarkerSet', str: 'std::ostream &') -> "void":
    return _pyaruco.FractalMarkerSet__toStream(configuration, str)
FractalMarkerSet__toStream = _pyaruco.FractalMarkerSet__toStream

def FractalMarkerSet__fromStream(configuration: 'FractalMarkerSet', str: 'std::istream &') -> "void":
    return _pyaruco.FractalMarkerSet__fromStream(configuration, str)
FractalMarkerSet__fromStream = _pyaruco.FractalMarkerSet__fromStream

def FractalMarkerSet_isPredefinedConfigurationString(str: 'std::string') -> "bool":
    return _pyaruco.FractalMarkerSet_isPredefinedConfigurationString(str)
FractalMarkerSet_isPredefinedConfigurationString = _pyaruco.FractalMarkerSet_isPredefinedConfigurationString

def FractalMarkerSet_getTypeString(t: 'aruco::FractalMarkerSet::CONF_TYPES') -> "std::string":
    return _pyaruco.FractalMarkerSet_getTypeString(t)
FractalMarkerSet_getTypeString = _pyaruco.FractalMarkerSet_getTypeString

def FractalMarkerSet_getTypeFromString(str: 'std::string') -> "aruco::FractalMarkerSet::CONF_TYPES":
    return _pyaruco.FractalMarkerSet_getTypeFromString(str)
FractalMarkerSet_getTypeFromString = _pyaruco.FractalMarkerSet_getTypeFromString

def FractalMarkerSet_load(info: 'std::string') -> "aruco::FractalMarkerSet":
    return _pyaruco.FractalMarkerSet_load(info)
FractalMarkerSet_load = _pyaruco.FractalMarkerSet_load

def FractalMarkerSet_loadPredefined(*args) -> "aruco::FractalMarkerSet":
    return _pyaruco.FractalMarkerSet_loadPredefined(*args)
FractalMarkerSet_loadPredefined = _pyaruco.FractalMarkerSet_loadPredefined

def FractalMarkerSet_readFromFile(path: 'std::string') -> "aruco::FractalMarkerSet":
    return _pyaruco.FractalMarkerSet_readFromFile(path)
FractalMarkerSet_readFromFile = _pyaruco.FractalMarkerSet_readFromFile

def FractalMarkerSet_getConfigurations() -> "std::vector< std::string,std::allocator< std::string > >":
    return _pyaruco.FractalMarkerSet_getConfigurations()
FractalMarkerSet_getConfigurations = _pyaruco.FractalMarkerSet_getConfigurations

class FractalMarker(Marker3DInfo):
    __swig_setmethods__ = {}
    for _s in [Marker3DInfo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FractalMarker, name, value)
    __swig_getmethods__ = {}
    for _s in [Marker3DInfo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FractalMarker, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _pyaruco.new_FractalMarker(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addSubFractalMarker(self, submarker: 'FractalMarker') -> "void":
        return _pyaruco.FractalMarker_addSubFractalMarker(self, submarker)

    def findInnerCorners(self) -> "std::vector< cv::Point3f,std::allocator< cv::Point3f > >":
        return _pyaruco.FractalMarker_findInnerCorners(self)

    def mat(self) -> "cv::Mat const":
        return _pyaruco.FractalMarker_mat(self)

    def mask(self) -> "cv::Mat const":
        return _pyaruco.FractalMarker_mask(self)

    def nBits(self) -> "int":
        return _pyaruco.FractalMarker_nBits(self)

    def subMarkers(self) -> "std::vector< int,std::allocator< int > >":
        return _pyaruco.FractalMarker_subMarkers(self)

    def getInnerCorners(self) -> "std::vector< cv::Point3f,std::allocator< cv::Point3f > >":
        return _pyaruco.FractalMarker_getInnerCorners(self)
    __swig_destroy__ = _pyaruco.delete_FractalMarker
    __del__ = lambda self: None
FractalMarker_swigregister = _pyaruco.FractalMarker_swigregister
FractalMarker_swigregister(FractalMarker)

class ScopeTimer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScopeTimer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScopeTimer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["begin"] = _pyaruco.ScopeTimer_begin_set
    __swig_getmethods__["begin"] = _pyaruco.ScopeTimer_begin_get
    if _newclass:
        begin = _swig_property(_pyaruco.ScopeTimer_begin_get, _pyaruco.ScopeTimer_begin_set)
    __swig_setmethods__["end"] = _pyaruco.ScopeTimer_end_set
    __swig_getmethods__["end"] = _pyaruco.ScopeTimer_end_get
    if _newclass:
        end = _swig_property(_pyaruco.ScopeTimer_end_get, _pyaruco.ScopeTimer_end_set)
    __swig_setmethods__["name"] = _pyaruco.ScopeTimer_name_set
    __swig_getmethods__["name"] = _pyaruco.ScopeTimer_name_get
    if _newclass:
        name = _swig_property(_pyaruco.ScopeTimer_name_get, _pyaruco.ScopeTimer_name_set)
    __swig_setmethods__["use"] = _pyaruco.ScopeTimer_use_set
    __swig_getmethods__["use"] = _pyaruco.ScopeTimer_use_get
    if _newclass:
        use = _swig_property(_pyaruco.ScopeTimer_use_get, _pyaruco.ScopeTimer_use_set)
    NSEC = _pyaruco.ScopeTimer_NSEC
    MSEC = _pyaruco.ScopeTimer_MSEC
    SEC = _pyaruco.ScopeTimer_SEC
    __swig_setmethods__["sc"] = _pyaruco.ScopeTimer_sc_set
    __swig_getmethods__["sc"] = _pyaruco.ScopeTimer_sc_get
    if _newclass:
        sc = _swig_property(_pyaruco.ScopeTimer_sc_get, _pyaruco.ScopeTimer_sc_set)

    def __init__(self, *args):
        this = _pyaruco.new_ScopeTimer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pyaruco.delete_ScopeTimer
    __del__ = lambda self: None
ScopeTimer_swigregister = _pyaruco.ScopeTimer_swigregister
ScopeTimer_swigregister(ScopeTimer)

class ScopedTimerEvents(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScopedTimerEvents, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScopedTimerEvents, name)
    __repr__ = _swig_repr
    NSEC = _pyaruco.ScopedTimerEvents_NSEC
    MSEC = _pyaruco.ScopedTimerEvents_MSEC
    SEC = _pyaruco.ScopedTimerEvents_SEC
    __swig_setmethods__["sc"] = _pyaruco.ScopedTimerEvents_sc_set
    __swig_getmethods__["sc"] = _pyaruco.ScopedTimerEvents_sc_get
    if _newclass:
        sc = _swig_property(_pyaruco.ScopedTimerEvents_sc_get, _pyaruco.ScopedTimerEvents_sc_set)
    __swig_setmethods__["vtimes"] = _pyaruco.ScopedTimerEvents_vtimes_set
    __swig_getmethods__["vtimes"] = _pyaruco.ScopedTimerEvents_vtimes_get
    if _newclass:
        vtimes = _swig_property(_pyaruco.ScopedTimerEvents_vtimes_get, _pyaruco.ScopedTimerEvents_vtimes_set)
    __swig_setmethods__["names"] = _pyaruco.ScopedTimerEvents_names_set
    __swig_getmethods__["names"] = _pyaruco.ScopedTimerEvents_names_get
    if _newclass:
        names = _swig_property(_pyaruco.ScopedTimerEvents_names_get, _pyaruco.ScopedTimerEvents_names_set)
    __swig_setmethods__["_name"] = _pyaruco.ScopedTimerEvents__name_set
    __swig_getmethods__["_name"] = _pyaruco.ScopedTimerEvents__name_get
    if _newclass:
        _name = _swig_property(_pyaruco.ScopedTimerEvents__name_get, _pyaruco.ScopedTimerEvents__name_set)

    def __init__(self, *args):
        this = _pyaruco.new_ScopedTimerEvents(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add(self, name: 'std::string') -> "void":
        return _pyaruco.ScopedTimerEvents_add(self, name)

    def addspaces(self, str: 'std::vector< std::string,std::allocator< std::string > > &') -> "void":
        return _pyaruco.ScopedTimerEvents_addspaces(self, str)
    __swig_destroy__ = _pyaruco.delete_ScopedTimerEvents
    __del__ = lambda self: None
ScopedTimerEvents_swigregister = _pyaruco.ScopedTimerEvents_swigregister
ScopedTimerEvents_swigregister(ScopedTimerEvents)

class Timer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Timer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Timer, name)
    __repr__ = _swig_repr
    NSEC = _pyaruco.Timer_NSEC
    MSEC = _pyaruco.Timer_MSEC
    SEC = _pyaruco.Timer_SEC
    __swig_setmethods__["_s"] = _pyaruco.Timer__s_set
    __swig_getmethods__["_s"] = _pyaruco.Timer__s_get
    if _newclass:
        _s = _swig_property(_pyaruco.Timer__s_get, _pyaruco.Timer__s_set)
    __swig_setmethods__["sum"] = _pyaruco.Timer_sum_set
    __swig_getmethods__["sum"] = _pyaruco.Timer_sum_get
    if _newclass:
        sum = _swig_property(_pyaruco.Timer_sum_get, _pyaruco.Timer_sum_set)
    __swig_setmethods__["n"] = _pyaruco.Timer_n_set
    __swig_getmethods__["n"] = _pyaruco.Timer_n_get
    if _newclass:
        n = _swig_property(_pyaruco.Timer_n_get, _pyaruco.Timer_n_set)
    __swig_setmethods__["_name"] = _pyaruco.Timer__name_set
    __swig_getmethods__["_name"] = _pyaruco.Timer__name_get
    if _newclass:
        _name = _swig_property(_pyaruco.Timer__name_get, _pyaruco.Timer__name_set)

    def __init__(self, *args):
        this = _pyaruco.new_Timer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setName(self, name: 'std::string') -> "void":
        return _pyaruco.Timer_setName(self, name)

    def start(self) -> "void":
        return _pyaruco.Timer_start(self)

    def end(self) -> "void":
        return _pyaruco.Timer_end(self)

    def _print(self, *args) -> "void":
        return _pyaruco.Timer__print(self, *args)

    def getAverage(self, *args) -> "double":
        return _pyaruco.Timer_getAverage(self, *args)
    __swig_destroy__ = _pyaruco.delete_Timer
    __del__ = lambda self: None
Timer_swigregister = _pyaruco.Timer_swigregister
Timer_swigregister(Timer)


def __pf_aruco_methodName(prettyFunction: 'std::string') -> "std::string":
    return _pyaruco.__pf_aruco_methodName(prettyFunction)
__pf_aruco_methodName = _pyaruco.__pf_aruco_methodName
# This file is compatible with both classic and new-style classes.


